# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```

- 如果想要研究for...in 这样的方法到底做了什么，就将其展开。

```swift
var g = arrar.generate()

while let obj = g.next(){
    print(obj)
}
```

- 顺便可以得到的收益可以使用map，filter和reduce这些方法，因为SequenceType接口扩展(protocol extension）已经实现他们

```swift
extension SequenceType {
    func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->[T]
    func filter(@noescape includeElement:(Self.Generator.Element) -> Bool) -> [Self.Generator.Element]
    func reduce<T>(inittial: T,@noescape combine: (T, Self.Generator.Element) - >T) -> T
}
```

### 多元组(Tuple)

- 交换输入

```swift

func swapMe<T>(inout a: T, inout b: T){
    let temp = a
    a = b
    b = temp
}

```

- 上述是普通的写法，一下就是使用多元组的话，我们可以不适用额外空间完成交换

```swift
func swapMe<T>(inout a: T, inout b: T){
    (a,b) = (b,a)
}
```

- 说明：
1. 在oc中有不少需要传递指针的地方，以前的错误处理NSError就是个很好的例子，不过在Swift2.0中，传入指针的NSError已经新加入的异常机制取代，所以举例说明

```
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)

CGRect rect = CGRectMake(0,0,100,100);
CGRect small;
CGRect large;
CGRectDivide(rect, &small, &large, 20, CGRectGetMinXEdge);
```

- 上诉代码不直观又很麻烦，我们用Swift采用多元组方式同时返回被分割的部分和剩余的部分

```swift
extension CGRect {
    func divide(atDistance: CGFloat, formEdge: CGRectEdge) ->(slice: CGRect,remainder: CGRect)
}
```

- 然后使用时，相比之前的做法，现在就非常简单了，而且非常容易理解

```swift
let rect = CGRectMake(0,0,100,100)
let (small,large) = rect.divide(20,fromEdge: .MinXEdge)
```

### @autoclosure和 ？？

- @autoclosure做的事情就是把一句表达式自动分封装成一个闭包(closure)

- 比如我们有一个方法接受一个闭包，当闭包执行的结果true的时候进行打印

```swift
func logIfTrue(predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```
- 在调用的时候，代码可以这样写

```swift
logIfTrue({return 2 > 1})
```
- 当然对闭包的用法可以进行一步简化

```swift
logIfTrue({2 > 1})
```
- 还可以更进一步，因为这个闭包是最后一个参数，所以可以用尾随闭包的方式把大括号拿出来，然后省略
```swift
logIfTrue{2 > 1}
```
-  @autoclosure来实现效果，在参数前面加上 @autoclosure关键字

```swift
func logIfTure(@autoclosure predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```

- 这时候我们可以直接使用下面的代码进行强调用,自动转换为() -> Bool 

```swift
logIfTure(2 > 1)
```

1. 在Swift中，有一个非常有用的操作符，可以用来快速对nil进行条件判断，那就是 ？？ 这个操作符可以判断输入内容，并在当左侧的值是非nil的optional值时返回其value，左侧是nil时返回右侧的值
2.比如

```swift
var level : Int?
var startLevel = 1

var currentLevel = level ?? startLevel
```
3. 说明

- 在这个例子中我们没有设置过level，因此最后startLeveal被赋值给currentLevel。我们看看 ？？的定义

```swift
func ??<T>(optional: T?,@autoclosure defaultValue: () -> T?) -> T?

func ??<T>(optional: T?,@autoclosure defaultValue: () -> T) -> T
```
- 在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int，但其实在使用时它被自动封装成一个() -> Intt 有了这个提示，测试一下

```swift
func ??<T>(optional: T?, @autoclosure defauleValue: () -> T) -> T {
    switch optional {
    case .Some(let value):
        return value
    case .None:
        return defauleValue()
    }
}
```

- 1. 为什么这里要使用autoclosure，直接接受T作为参数并返回不行吗？这正是autoclosure的一个最值得称赞的地方。假设使用T，那么意味着？？操作符真正取值之前，我们必须准备好一个默认值，这个默认值的准备和计算会降低性
- 2. 我们可以巧妙绕过条件判断和强制转换，以很优雅的写法处理对optional默认值取值了。

### Optional Chaining


------------

- 使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要谨慎，因为Optional Chaining是随时都可能提前返回nil，所以使用Optional Chaining所得到的东西其实都是optional

```swift
class Toy {
    let name: String
    init(name: String){
        self.name = name
    }
    
}

class Pet {
    var toy: Toy?
}

class child {
    var pet: Pet?
}

```

- 在实际使用中，我们想知道小明的宠物的玩具名字的时候，可以通过以下的**Optional Chaining**得到

```swift
let toyName = xiaoming.pet?.toy?.name
```

1. 注意我们最后访问的是name，并且在Toy的定义中name是被定义一个确定的String而非String？但是我们得到的toyName其实还是一个Strin类型，这是由于在Optional Chaining中，我们任意一个 ？.的时候可能遇到nil提前返回，这个时候只能得到nil
2. 在实际使用中，我们在大多数情况下可能更希望使用Optional Chaining来直接取值的代码

```swift
if let toyName = xiaoming.pet?.toy?.name {
    //太好了，小明有宠物，而且宠物还是正好有个玩具
}
```

3. 可能单独拿出来会很清楚，不过稍微结合一下其他特征就会变得很复杂起来

```swift
extension Toy {
    func play(){
    
    }
}
```

4. 我们为Toy定义一个扩展，以及一个玩玩具的play()方法，还是举例小明有玩具玩

```swift
xiaoming.pet?.toy?.play()
```
- 除了小明，还有有很多人等，这时候我们会想要把这一串抽象出来，做一个闭包以方便使用，传入一个child对象，日过小朋友有宠物并且宠物有玩具的话，就去玩

```swift
//无意义代码
let playClosure = {(child: child) -> () in child.pet?.toy?.play()}
```

- **问题在哪里？**

1. play()调用上，定义的时候没有卸载play()的返回，这表示这个方法返回Void。但是经过Optional Chaining得到的optional的结果，也就是说，我们最后得到应该是这样一个closure

```swift
//
let playClosure = {(child: child) -> ()? in child.pet?.toy?.play()}
```

- 这样调用的返回是一个()?，使用的时候我可以通过Optional Chaining来判定方法是否调用成功

```swift
if let result: () = playClosure(xiaoming) {
    print("好开心")
}else{
    print("没有玩具可玩 :(")
}
```
### 操作符
- 与oc不同swift支持重载操作符，它的最常见的使用方式可能就是定义一些简单的计算，比如我们需要一个表示二位向量的结构数据

```swift
struct Vector2D {
    var x = 0.0
    var y = 0.0
}

```

- 一个很简单的需求是两个Vector2D相加

```swift

let v1 = Vector2D(x:2.0,y: 3.0)
let v2 = Vector2D(x:1.0,y: 4.0)
let v3 = Vector2D(x:v1.x + v2.x,y: v1.y + v2.y)
//v3 为 {x 3.0 , y 7.0}
```

1. 如果只做一次的话还好，一般情况下我们会多次这种操作，这样的话，我们可能更愿意定义一个Vector2D相加的操作，来简化代码使其更清晰

2. 对一个两个向量相加，我们可以重载加号操作符

```swift
func +(left: Vector2D, rigth: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + rigth.y, y: left.y + rigth.y)
}
```

- 这样上面两个向量相加的操作，就全部可以用加号表达了

```swift
let v4 = v1 + v2
// v4 为 {v 3.0, y 7.0}
```

- 上面定义的加号，减号，和负号已经存在swift中的运算符了，我们所做的只是变换它的参数进行重载，如果我们定义一个全新的运算符，要做的事情会更多一件，比如点积运算就，它表示两个向量对应坐标的乘积的和，根据定义，并参考重载运算符的方法，我们选取+*来表示这个运算

```swift
func +* (left: Vector2D, rigth: Vector2D) -> Double {
    return left.x * rigth.x + left.y * rigth.y
}
```

- 这是会报错，因为我们没有对这个操作符进行声明，之前可以直接重载 + - * 这样的操作符，是因为他们在swift中已经有定义了，如果我们要新加操作符的话，需要先对其进行声明，告诉编辑器这个月符号其实是一个操作符

```swift
infix operator +* {
    associativity nonoe
    precedence 160
}
```

##### infix

    表示定义的是一个中位操作符，即前后都是输入；其他的修饰子还包括prefix和postfix，不再赘述
	
	
##### 	associativity

    定义了结合律，即多个同类的操作符顺序出现时的计算顺序，比如常见的加法和减法都是left，就是多个加法同时出现时从左往右计算。点乘结果是Double，不会再和其他乘结合使用，所以这里写成none
	
##### 	precedence

    表示运算的优先级，越高越优先计算运算。swift中乘法和除法的优先级是150，加法和减法是140，这里我们定义点积的优先级为160，就是说它应该优先普通的乘除法进行运算
	
- 有了这些之后，我们就可以很简单地进行向量的点积运算了

```swift
let result = v1 +* v2
//输出为14.0
```

1. 最后需要多提一点的是，swift的操作符号是不能定义在局部域中的，因为一个操作符至少要能在全局范围使用，否则也就失去意义

2.另外来自不同module的操作符是有可能产生冲突的，这对于开发者来说是需要特别注意的地方

3.因此在重载或者定义的操作符时，应当尽量将其作为其他某个方法的“简便写法”，而避免在其中实现大量逻辑或者提供独一无二的功能，这样即使出现冲突，使用者也可是通过方法调用的方式使用你的库

## func的参数修饰

- 在声明一个swift的方法适合，我们一般不去指定参数前面的修饰符，而是直接声明参数

```swift
func incrementore(variable: Int) ->Int {
	return variable + 1
	
}
```

1. 这个方法接受一个Int的输入，然后通过将这个输入加1，返回一个新的比喻输入大1的Int，这其实就是一个简单的+1器

2. 错误代码

```swift
func incrementore(variable: Int) ->Int {
	return ++variable
	
}
```

- 会发现编译错误，为什么swift不行呢？因为swift其实一门讨厌变化的语言，所有可能的地方，都默认不可变得，也就是用let进行声明的，这样不仅可以确保安全，也能编译器的性能更有作为，在方法的参数也是如此

1. 我们不写修饰符的话，默认情况下所有参数都是let

```swift
func incrementore(let variable: Int) ->Int {
	return ++variable
	
}
```

2.let的参数不能重新赋值，这是理所当然，要让这个方法正确编译，我们需要做的改动是let 为 var

```swift
func incrementore(var variable: Int) ->Int {
	return ++variable
	
}
```

3. 现在我们的+1器又可以正确工作了：

```swift
func incrementore(var variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(luckyNumber)

//newNumber = 8

print(luckyNumber)
```

- 上面的例子，我们将参数写作var后，通过调用返回的值是正确的，而luckyNumber还保持了原来的值，这说明var只是在方法内部起作用，而不会直接影响输入的值
- 有些时候我们希望在方法内部直接修改输入的值，这个时候我们可以使用inout来对参数进行修饰

```swift
func incrementore(inout variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(&luckyNumber)

//newNumber = 8

print(luckyNumber)
```
- 注意的是参数修饰是具有传递限制的，我们需要保证统一参数的修饰统一的，举例

```swift
func makeIncrementor(addNumber: Int) -> ((inout Int) -> ()){
    func incrementor(inout variable: Int) -> () {
        variable += addNumber;
    }
    return incrementor;
}
```

## 字面量转换

- 所谓字面量，就是指特定的数字，字符串和不耳值这样，能够直截了指出自己的类型并未变量进行赋值的值

```swift
let aNumber = 3
let aString = "Hello"
let aBool = "ture"
```

1. 上述三个都是字面量
2. 在Swift中，Array，Dictionary在使用简单的描述赋值的时候，使用也是字面

```swift
let anArray = [1,2,3]
let aDictionary = ["key1":"value1","key2":"value2"]
```

- Swift为我们提供了很多接口，用来将字面量转换为特定的类型，对于那些实现了字面量转换接口的类型，在提供字面量赋值的时候，就可以简单德按照接口方法中定义

1. 所有的字面量转换接口都电影以一个typealias 和对应init方法
2. 举例

```swift

protocol BooleanLiteralConvertible {
    typealias BooleanLiteralType
    
    init(booleanLiteral value: BooleanLiteralType)
}
```

- 我们需要自己实现一个字面量转换，可以简单地实现定义的init方法，举一个不太有实际意义的的例子

```swift
enum MyBool : Int {
    case myTure, myFalse
}

extension MyBool: BooleanLiteralConvertible {
    init(booleanLiteral value: Bool) {
        self = value ? myTure : myFalse
    }
}


let myTure: MyBool = true
let myFalse: MyBool = false

myTure.rawValue
myFalse.rawValue
```

- 这样我们很容易直接使用Bool的ture和false来对Mybool类型进行赋值

- 举例二

```swift
class Person {
    let name: String
    init(name value: String){
        self.name = value
    }
}
 
```

- 如果通过String赋值来生产Person对象，可以这样写

```swift
//通过String赋值来生产Person对象，可以这样写

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required init(stringLiteral value: String) {
        self.name = value
    }
    required init(extendedGraphemeClusterLiteral value: String){
        self.name = value
    }
    required init(unicodeScalarLiteral value: String) {
        self.name = value
    }
}
```

```swift
//改善初始化方法中调用原来的init(name value: String)

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required convenience init(stringLiteral value: String) {
        self.init(name: value)
    }
    required convenience init(extendedGraphemeClusterLiteral value: String){
        self.init(name: value)
    }
    required convenience init(unicodeScalarLiteral value: String) {
        self.init(name: value)
    }
}

let p: Person = "xiaoMing"
print(p.name)
```


-  上面Person的例子中，我们没有像MyBool中做的哪像，使用extension的方式扩展类，使其中可以字面量渎职，这是因为而心疼死你哦中，我们是不能定义required的初始话方法的，也就是说，我们无法为现有的费final的class添加字面量转换

### 下标

- 在绝大多数语言中使用下标来读写类似数组和字典数据结构的做法，在swift中，array和dicitionary当然也可以实现下标方法来写

```swift
var arr = [1,2,3]
arr[2]
arr[2] = 4

var dic = ["cat":"meow","goat":"min"]
dic["cat"]
dic["cat"] = "miao"
```

- 我们通过下标访问得到的结果是一个Optional的值，这很容易理解，Swift是允许我们自定义下标，我们不仅能对自己写类型自定义下标，也能对那些已经支持小标访问的类型

```swift
subscript(index.Int) -> T
subscript(subRange:Range<Int>) -> Slice<T>

```

1. 他们共有两种，分别接受单个Int类型的序号和一个表明范围的Range<Int>,作为对应返回值也分别是单个元素和一组对应输入返回的元素
2. 我们很难一次性取出某个特定位置的元素。
3. 实心一个接受数组作为下标输入的读取方法

```swift
extension Array {
    subscript(input: [Int]) -> ArraySlice<Element> {
        get {
            var result = ArraySlice<Element>()
            for i in input {
                assert(i < self.count, "Index out of range")
                result.append(self[i])
            }
            return result
        }
        set {
            for(index,i) in input.enumerate(){
                assert(i < self.count, "Index out of range")
                self[i] = newValue[index]
            }
        }
    }
}

```

- 这样，我们的Array的灵活性大大增强了很多

### 方法嵌套

- 我们可以将方法当然变量或者参数来使用，更进一步，我们甚至可以在一个方法中定义新的方法
- 我们写一个网络请求的Request类，可能面临将请求的编码Ulr里的任务

```swift
func appendQuery(var url: String,
                     key: String,
                     value: AnyObject) -> String {
    
    if let dictionary = value as? [String: AnyObject] {
        
        return appendQueryDictionary(url,key,dictionary)
        
    } else if let array = value as? [AnyObject] {
        return appendQueryArray(url,key,array)
    } else {
        return appendQuerySingle(url,key,value)
    }
}
```

```swift
func appendQueryDictionary(var url: String, key: String, value: [String: AnyObject]) -> String{
    return result
}

func appendQueryArray(var url: String, key: String, value: AnyObject) -> String{
    return result
}

func appendQuerySingle(var url: String, key: String, value: AnyObject) -> String{
    return result
}

if let dictionary = value as? [String: AnyObject]{
    return appendQueryDictionary(url, key, dictionary)
}else if array = value as? [AnyObject]{
    return appendQueryArray(url,key,array)
}esle {
    return appendQuerySingle(url,key,value)
}

```

### 命名空间

1. oc一直以来一个地方没有命名空间，所有代码和引用的静态库最终同一个域和二进制中，这样一旦重复类名的话，就会导致编译冲突，我们看看Swift命名

```swift
public class MyClass {
    public class func hello(){
        print("Hello from framework")
    }
}

//class MyClass {
//    class func hello() {
//        print("hello from app")
//    }
//}
```

- 一种就是就是使用类型嵌套方法来指定访问的范围，常见的做法是将名字重复的类型定义到不同的struct中

```swift
struct MyClassContainer1 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer1")
        }
    }
}



struct MyClassContainer2 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer2")
        }
    }
}
```

### Any和AnyObject

1. Any和 AnyObject是Swift中两个妥协的产物

```swift
AnyObject可以代表任何class类型的实例
Any可以表示任何类型，甚至包括方法func类型
```

##### AnyObject


------------

oc中一个叫id的东西，编译器不会对声明id的变量进行类型的检查，它表示任何任意类的实例，


------------

区别

- 两者其实是有区别的，在Swift中编译器不仅不会对AnyObject实例的方法调用做出检查，甚至对AnyObject调用返回Optional的结果，这虽然是符合oc中的概念的，但是Swift环境使用起来就会很非常麻烦，也很危险


------------

- 举例，某个API返回的是一个id，那么在Swift中将被影射AnyObject是可以指定nil，所以这里我们需要一个optional版本

```swift
func someMethod() -> AnyObject? {
    
    //返回一个AnyObject？等价在oc中返回一个id
    return result
}

let anyObject: AnyObject？ = SomeClass.someMethod()
    if let someInstance = anyObject as? SomeRealClass {
        someInstance.funcOfSomeRealClass()
}

如果我们注意到AnyObject的定义，可以发现其实它是一个接口

protocol AnyObject {
    
}

```

* 特别之处，所有的class都是隐藏地实现了这个接口，这也是AnyObject只适用于class类型的原因，而在swift中所有的基本类型，包括Array 和 Dictionary 这些传统意义上是class的东西，都是struct类型，并不能由AnyObject来表示


```swift

let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [AnyObject] = []
array.append(swiftInt)
array.append(swiftString)

```

1. 这里声明一个**int**和**String**，都应该只能被**Any**代表，而不能被**AnyObject**代表
2. 如果去掉**import UIKit**的话就会发现变化

```swift
let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [Any] = []
array.append(swiftInt)
array.append(swiftString)

```

*     **值得一提的是，只使用Swift类型而不转换为Cocoa类型，对性能所有帮助**

### typealias 和泛型接口

* typealias是用来已经存在的重新定义的名字，可以是代码更加清晰
* 使用的语法也十分的简单
* 例子

```swift


func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -> Double {
    
    let dx  =  Double(toPoint.x - toPoint.y)
    let dy  =  Double(toPoint.x - toPoint.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: CGPoint = CGPoint(x: 0, y: 0)
let point: CGPoint = CGPoint(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, toPoint: point)

```

*使用typealias，就可以直接代码里*

```swift

typealias Loaction = CGPoint
typealias Distance = Double

func distanceBetweenPoint(loaction: Loaction, tolocation: Loaction) -> Distance {
    
    let dx  =  Double(loaction.x - tolocation.y)
    let dy  =  Double(loaction.x - tolocation.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: Loaction = Loaction(x: 0, y: 0)
let point: Loaction = Loaction(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, tolocation: point)

```

1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型确定后我们就可以重新命名，另外swift种没有泛型接口
4. 例子来为接口确定一个使用的类型泛型特征


    
```swift

protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element?
}

protocol SquenceType {
    typealias Generator : GeneratorType
    func generate() -> Self.Generator
}
```


1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型类型的确定性得到保证后，我们可以重名了


```swift
 class Person<T>{}

typealias WordId = String
typealias Worker = Person<WorkId>

```

* Swift中没有泛型接口，但是使用typealias我们可以在接口里定义一个必须实现的别名，swift都用到这个技巧


```swift
protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element
}


protocol SqeuenceType {
    typealias Generator : GeneratorType
    func generator() -> Self.Generator
}
```

### 可变参数函数

1. 可变参数函数指的是可以直接接受任意多个参数的函数，我们最熟悉的就是NSString的 -stringwithFormat方法了
2. 下面例子方法参数可以任意变化的，参数第一项是需要格式化的字符串，后面的参数都是第一个参数填空
3. 但是swift简化了很多，写一个可变参数的函数只需要声明参数时在类型后面加上...就可以了


```object-C
NSString *name = @"Tom";
NSData *date = [NSDate date];
NSString *string = [NSString stringWithForamt: @"Hello %@. Date: %@",name,date];
```

4.可变参数旺旺只能作为方法的最后一个参数来使用，而不能呢先声明一个可变参数，然后再声明其他参数，所以我们可以随意放可变参数的位置

```swift
func sum(input: Int...) -> Int{
    return input.reduce(0, combine: +)
}

print(sum(1,2,3,4,5))

```


```swift

func myFunc(number: Int..., string: String){
    number.forEach{
        for i in 0..<$0{
            print("(i + 1): \(string)")
        }
    }
}

myFunc(1,2,3,string: "hello")
```

* 限制自然有的，比如同一个方法只能有一个参数可变的,可变参数都是必须同一种类型，等等
* 比如swift的NSString格式化的声明就是这样处理


```swift

extension NSString {
    convenience init(format: NSString, _ args: CVarArgType...)
        
    
}
```
* 调用的时候和oc一样了


```swift

let name = "Tom"
let date = NSDate()
let string = NSString(format: "Hello %@. Date: %@",name,date)
```

### 初始化方法顺序

1. swift初始化方法需要保证类型的所有属性都被初始化，所以初始化方法的调用顺序很有讲究，在某个类中，初始化方法顺序并不是随意的


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        super.init()
        name = "tiger"
    }
}
```
2. 一般来说，子类的初始化顺序是

*     设置子类自己需要初始化的参数
*     调父类相应的初始化方法 super.init（）
*     对父类的需要改变程序进行设定，name = "tiger"


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        //如果我们需要改变name的话
        //虽然我们没有显示对super.init()进行调用
        //不过由于这是初始话的最后了，swift替我们自动完成
    }
}

```

### Designated,Convenience和Required
1. oc中，init方法是非常不安全的，没有人保证init只能调用一次，也没有人保证初始化调用以后实例的各个变量都完成初始化，甚至如果在初始化里使用属性进行设置的话，还可能造成各种问题
2. 下面代码，注意init里我们可对let的实例常量赋值，这是初始化方法的重要特点


```swift
class ClassA {
    let numA: Int
    init(num: Int){
        numA = num
    }
}

class ClassB: ClassA {
    let numB: Int
    
    override init(num: Int) {
        numB = num + 1
        
        super.init(num: num)
    }
}
```

3.  Designated初始化方法对应的是init前面加上Convenience关键字的初始方法，这类方法是swift初始化方法的“二等公民”


```swift


class ClassA {
    let numA: Int
    init(num: Int){
        numA = num
    }
    
    convenience init(bigNum: Bool){
        self.init(num:bigNum ? 1000 : 1)
    }
}



class ClassB: ClassA {
    let numB: Int
    
    override init(num: Int) {
        numB = num + 1
        
        super.init(num: num)
    }
}
```
4.   只有在子类实现重写父类convenience方法所需要init方法，我们在子类中就可以使用父类convenience方法

* 初始化路径必须保证对象完全初始化，这可以通过调用类型Designated初始化得到保证
* 子类的Designated初始化方法必须调用父类的designated方法来完成初始化

### 初始化返回nil
1. oc中init方法返回self以外，其实和一个普通的实例方法并没有太大的区别，但是swift中默认情况下初始化方法是不能写成retur语句来返回值的，也就说我们没有机会初始化一个optional的值
2. 一个很经典的例子就是初始化一个url，在oc中，如果我们使用一个错误的字符串来初始化一个NSURL对象，返回时nil，达标初始化失败，只是结果是nil

```oc
    NSURL *url = [NSURL alloc] initWithString:@"http://swifter.tips"];
    NSLog(@"%@"，url);
    
```


```swift
    let url = NSURL(string: "http://swifter.tips")
print(url)
    
```
3.如果是swift 1.0的话

```swift
    class func URLWithString(URLString: String!) -> self!

let url = NSURL(string: "http://swifter.tips")
print(url)
    
```

4.如果是swift 2.2


```swift
extension Int {
    init?(fromString: String){
        self = 0
        var digit = fromString.characters.count - 1
        for c in fromString.characters {
            var number = 0
            if let n = Int(String(c)){
                number = n
            }else {
                switch c {
                    case "一": number = 1
                    case "二": number = 2
                    case "三": number = 3
                    case "四": number = 4
                    case "五": number = 5
                    case "六": number = 6
                    case "七": number = 7
                    case "八": number = 8
                    case "九": number = 9
                default:return nil
                }
            }
            self = self + number * Int(pow(10, Double(digit)))
            digit = digit - 1
        }
    }
}

let number1 = Int(fromString: "12")

let number2 = Int(fromString: "三二五")

let number3 = Int(fromString: "七9八")

let number4 = Int(fromString: "吃了吗")

let number5 = Int(fromString: "1a4n")
```

* 所有结果都是Int?类型，通过Optional Binding，我们就能知道初始化是否成功，并安全的使用它们，在初始化失败的情况下，我们应该使用返回nil的初始化方法，而不是类型工厂方法

### Protocol组合

* 在swift中我们可以使用any来表示任意类型，这个类型的定义十分奇怪，它是一个Protocol<>的同名类型
* 像Protocol<>这种形式的写法在swift的日常使用并不多见，这其实是swift的接口组合的用法，标准的形式是
* protocol < ProtocolA,ProtocolB,ProtocolC >
* 例子，有三个接口，分别代表三种动物，而有一种“谜之动物”，同时实现了这三个接口


```swift
protocol KittenLike {
    func meow() -> String
}

protocol DogLike {
    func brak() -> String
}

protocol TigerLike {
    func aou() -> String
}

class MyterAnimal: KittenLike,DogLike,TigerLike {
    func meow() -> String {
        return "meow"
    }
    
    func brak() -> String {
        return "bark"
    }
    
    func aou() -> String {
        return "aou"
    }
}

```
* 现在我们想要检验某种动物作为宠物的时候的叫声的话，可能重新定义一个叫做PetLike的接口，表示实现了PetLike和DogLike


```swif
protocol PetLike: KittenLike,DogLike {
    
}

protocol CatLike: KittenLike,DogLike {
    
}

struct SoundChecker {
    static func checkPetTalking(pet: PetLike){
    
    }
    static func checkCatTalking(cat: PetLike){
        
    }
}

```
1. 虽然没有引入定义任何新的内容，但是为了实现这个需求，我们还是添加了两个空 protocol，这可能会让人困惑，代码的使用者 (也包括一段时间后的你自己) 可能会去猜测 PetLike 和 CatLike 的作用 --
2.  其实它们除了标注以外并没有其他作用。借助 protocol 组合的特性，我们可以很好的解决这个问题。protocol 组合是可以使用 typealias 来命名的，于是可以将上面的新定义 protocol 的部分换为：


```swift
typealias PetLike = protocol<KittenLike, DogLike>
typealias CatLike = protocol<KittenLike, TigerLike>
```

* 这样既保持了可读性，也没有多定义不必要的新类型。
* 另外，其实如果这两个临时接口我们就只用一次的话，如果上下文里理解起来不会有困难，我们完全可以直接将它们匿名化，变成下面这样：


```swift
struct SoundChecker {
    static func checkPetTalking(pet: protocol<KittenLike, DogLike>) {
        //...
    }

    static func checkCatTalking(cat: protocol<KittenLike, TigerLike>) {
        //...
    }
}
```
* 两个接口中 bar() 只有返回值的类型不同。
* 我们如果有一个类型 Class 同时实现了 A 和 B，我们要怎么才能避免和解决调用冲突呢？


```swift
class Class: A, B {
    func bar() -> Int {
        return 1
    }

    func bar() -> String {
        return "Hi"
    }
}
```

这样一来，对于 bar()，只要在调用前进行类型转换就可以了：


```swift
let instance = Class()
let num = (instance as A).bar()  // 1
let str = (instance as B).bar()  // "Hi"
```

### static和class

1. Swift 中表示 “类型范围作用域” 这一概念有两个不同的关键字，它们分别是 static 和 class。
2. 这两个关键字确实都表达了这个意思，但是在其他一些语言，包括 Objective-C 中，我们并不会特别地区分类变量/类方法和静态变量/静态函数。但是在 Swift 的早期版本中中，这两个关键字却是不能用混的。
3. 在非 class 的类型上下文中，我们统一使用 static 来描述类型作用域。
4. 这包括在 enum 和 struct 中表述类型方法和类型属性时。在这两个值类型中，
5. 我们可以在类型范围内声明并使用存储属性，计算属性和方法。static 适用的场景有这些：


```swift
struct Point {
    let x: Double
    let y: Double

    // 存储属性
    static let zero = Point(x: 0, y: 0)

    // 计算属性
    static var ones: [Point] {
        return [Point(x: 1, y: 1),
                Point(x: -1, y: 1),
                Point(x: 1, y: -1),
                Point(x: -1, y: -1)]
    }

    // 类型方法
    static func add(p1: Point, p2: Point) -> Point {
        return Point(x: p1.x + p2.x, y: p1.y + p2.y)
    }
}
```

* enum 的情况与这个十分类似，就不再列举了。
* class 关键字相比起来就明白许多，是专门用在 class 类型的上下文中的，可以用来修饰类方法以及类的计算属性。
* 但是有一个例外，class 中现在是不能出现 class 的存储属性的，我们如果写类似这样的代码的话：


```swift
class MyClass {
    class var bar: Bar?
}
```

*编译时会得到一个错误*
*在 Swift 1.2 及之后，我们可以在 class 中使用 static 来声明一个类作用域的变量。也即：*

```swift
class MyClass {
    static var bar: Bar?
}
```

* 有一个比较特殊的是 protocol。在 Swift 中 class，struct 和 enum 都是可以实现某个 protocol 的。
* 那么如果我们想在 protocol 里定义一个类型域上的方法或者计算属性的话，应该用哪个关键字呢？
* 答案是使用 static 进行定义。在使用的时候，struct 或 enum 中仍然使用 static，而在 class 里我们既可以使用 class 关键字，也可以用 static，它们的结果是相同的：


```swift
protocol MyProtocol {
    static func foo() -> String
}

struct MyStruct: MyProtocol {
    static func foo() -> String {
        return "MyStruct"
    }
}

enum MyEnum: MyProtocol {
    static func foo() -> String {
        return "MyEnum"
    }
}

class MyClass: MyProtocol {
    // 在 class 中可以使用 class
    class func foo() -> String {
        return "MyClass.foo()"
    }

    // 也可以使用 static
    static func bar() -> String {
        return "MyClass.bar()"
    }
}
```

**在 Swift 1.2 之前 protocol 中使用的是 class 作为关键字，但这确实是不合逻辑的。Swift 1.2 和 2.0 分两次对此进行了改进。现在只需要记住结论，在任何时候使用 static 应该都是没有问题的。**

### 多类型和容器

##### Swift 中常用的原生容器类型有三种，它们分别是 Array、Dictionay 和 Set


```swift
struct Array<Element> :
    CollectionType, Indexable, SequenceType,
    MutableCollectionType, _DestructorSafeContainer {

    //...

}

struct Dictionary<Key : Hashable, Value> :
    CollectionType, Indexable, SequenceType,
    DictionaryLiteralConvertible {

    //...

}

public struct Set<Element : Hashable> : 
    Hashable, Equatable, CollectionType, Indexable, 
    SequenceType, ArrayLiteralConvertible {

    //...

}
```

*它们都是泛型的，也就是说我们在一个集合中只能放同一个类型的元素。比如*


```swift
let numbers = [1,2,3,4,5]
// numbers 的类型是 [Int]

let strings = ["hello", "world"]
// strings 的类型是 [String]
```
*如果我们要把不相关的类型放到同一个容器类型中的话，一个比较容易想到的是使用 Any 或者 AnyObject，或者是使用 NSArray：*


```swift
import UIKit

let mixed: [Any] = [1, "two", 3]

// 如果不指明类型，由于 UIKit 的存在
// 将被推断为 [NSObject]
let objectArray = [1, "two", 3]
```
*这样的转换会造成部分信息的损失，我们从容器中取值时只能得到信息完全丢失后的结果，在使用时还需要进行一次类型转换。这其实是在无其他可选方案后的最差选择：因为使用这样的转换的话，编译器就不能再给我们提供警告信息了。我们可以随意地将任意对象添加进容器，也可以将容器中取出的值转换为任意类型，这是一件十分危险的事情：*

```swift
let any = mixed[0]  // Any 类型
let nsObject = objectArray[0] // NSObject 类型
```

**其实我们注意到，Any 其实是 protocol，而不是具体的某个类型。因此就是说其实在容器类型泛型的帮助下，我们不仅可以在容器中添加同一具体类型的对象，也可以添加实现了同一接口的类型的对象。绝大多数情况下，我们想要放入一个容器中的元素或多或少会有某些共同点，这就使得用接口来规定容器类型会很有用。比如上面的例子如果我们希望的是打印出容器内的元素的 description，可能我们更倾向于将数组声明为 [CustomStringConvertible] 的：**


```swift
import Foundation
let mixed: [CustomStringConvertible] = [1, "two", 3]

for obj in mixed {
    print(obj.description)
}
```

**这种方法虽然也损失了一部分类型信息，但是相对于 Any 或者 AnyObject 还是改善很多，在对于对象中存在某种共同特性的情况下无疑是最方便的。另一种做法是使用 enum 可以带有值的特点，将类型信息封装到特定的 enum 中。下面的代码封装了 Int 或者 String 类型：**

```swift
import Foundation
enum IntOrString {
    case IntValue(Int)
    case StringValue(String)
}

let mixed = [IntOrString.IntValue(1),
             IntOrString.StringValue("two"),
             IntOrString.IntValue(3)]

for value in mixed {
    switch value {
    case let .IntValue(i):
        print(i * 2)
    case let .StringValue(s):
        print(s.capitalizedString)
    }
}

// 输出：
// 2
// Two
// 6
```

* 通过这种方法，我们完整地在编译时保留了不同类型的信息。为了方便，我们甚至可以进一步为 IntOrString 使用字面量转换的方法编写简单的获取方式，但那是另外一个故事了

### default参数

1. Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。
2. 在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。
3. 可以说这是 Objective-C 社区盼了好多年的一个特性了，Objective-C 由于语法的特点几乎无法在不大幅改动的情况下很好地实现默认参数。
4. 和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 "默认参数之后不能再出现无默认值的参数"这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：


```swift
func sayHello1(str1: String = "Hello", str2: String, str3: String) {
    print(str1 + str2 + str3)
}

func sayHello2(str1: String, str2: String, str3: String = "World") {
    print(str1 + str2 + str3)
}
```

**其他不少语言只能使用后面一种写法，将默认参数作为方法的最后一个参数。
在调用的时候，我们如果想要使用默认值的话，只要不传入相应的值就可以了。下面这样的调用将得到同样的结果：**


```swift
sayHello1(str2: " ", str3: "World")
sayHello2("Hello", str2: " ")

//输出都是 Hello World
```

**这两个调用都省略了带有默认值的参数，sayHello1 中 str1 是默认的 "Hello"，而 sayHello2 中的 str3 是默认的 "World"。
另外如果喜欢 Cmd + 单击点来点去到处看的朋友可能会注意到 NSLocalizedString 这个常用方法的签名现在是：**


```swift
func NSLocalizedString(key: String,
                 tableName: String? = default,
                    bundle: NSBundle = default,
                     value: String = default,
                   comment: String) -> String
```

* 默认参数写的是 default，这是含有默认参数的方法所生成的 Swift 的调用接口。
* 当我们指定一个编译时就能确定的常量来作为默认参数的取值时，这个取值是隐藏在方法实现内部，而不应该暴露给其他部分。与 NSLocalizedString 很相似的还有 Swift 中的各类断言：


```swift
func assert(@autoclosure condition: () -> Bool,
            @autoclosure _ message: () -> String = default,
                              file: StaticString = default,
                              line: UWord = default)
```

### 正则表达式

1. 作为一门先进的编程语言，Swift 可以说吸收了众多其他先进语言的优点，但是有一点却是让人略微失望的，就是 Swift 至今为止并没有在语言层面上支持正则表达式。
2. 大概是因为其实 app 开发并不像 Perl 或者 Ruby 那样的语言需要处理很多文字匹配的问题，Cocoa 开发者确实不是特别依赖正则表达式。但是并不排除有希望使用正则表达式的场景，我们是否能像其他语言一样，使用比如 =~ 这样的符号来进行正则匹配呢？
3. 最容易想到也是最容易实现的当然是自定义 =~ 这个运算符。在 Cocoa 中我们可以使用 NSRegularExpression 来做正则匹配，那么其实我们为它写一个包装也并不是什么太困难的事情。因为做的是字符串正则匹配，所以 =~ 左右两边都是字符串。
4. 我们可以先写一个接受正则表达式的字符串，以此生成 NSRegularExpression 对象。然后使用该对象来匹配输入字符串，并返回结果告诉调用者匹配是否成功。一个最简单的实现可能是下面这样的


```swift
struct RegexHelper {
    let regex: NSRegularExpression

    init(_ pattern: String) throws {
        try regex = NSRegularExpression(pattern: pattern,
            options: .CaseInsensitive)
    }

    func match(input: String) -> Bool {
        let matches = regex.matchesInString(input,
                    options: [],
                    range: NSMakeRange(0, input.utf16.count))
        return matches.count > 0
    }
}
```

**在使用的时候，比如我们想要匹配一个邮箱地址，我们可以这样来使用：**


```swift
let mailPattern =
"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$"

let matcher: RegexHelper
do {
    matcher = try RegexHelper(mailPattern)
}

let maybeMailAddress = "onev@onevcat.com"

if matcher.match(maybeMailAddress) {
    print("有效的邮箱地址")
}
// 输出:
// 有效的邮箱地址
```

**现在我们有了方便的封装，接下来就让我们实现 =~ 吧。这里只给出结果了，关于如何实现操作符和重载操作符的内容，可以参考操作符一节的内容。**


```swift
infix operator =~ {
    associativity none
    precedence 130
}

func =~(lhs: String, rhs: String) -> Bool {
    do {
        return try RegexHelper(rhs).match(lhs)
    } catch _ {
        return false
    }
}
```

* 这下我们就可以使用类似于其他语言的正则匹配的方法了：


```swift
if "onev@onevcat.com" =~
    "^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$" {
        print("有效的邮箱地址")
}
// 输出:
// 有效的邮箱地址
```

### 模式匹配

1. 在之前的正则表达式中，我们实现了 =~ 操作符来完成简单的正则匹配。虽然在 Swift 中没有内置的正则表达式支持，但是一个和正则匹配有些相似的特性其实是内置于 Swift 中的，那就是模式匹配。
2. 当然，从概念上来说正则匹配只是模式匹配的一个子集，但是在 Swift 里现在的模式匹配还很初级，也很简单，只能支持最简单的相等匹配和范围匹配。在 Swift 中，使用 ~= 来表示模式匹配的操作符。如果我们看看 API 的话，可以看到这个操作符有下面几种版本：


```swift
func ~=<T : Equatable>(a: T, b: T) -> Bool

func ~=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool

func ~=<I : IntervalType>(pattern: I, value: I.Bound) -> Bool
```

* 从上至下在操作符左右两边分别接收可以判等的类型，可以与 nil 比较的类型，以及一个范围输入和某个特定值，返回值很明了，都是是否匹配成功的 Bool 值。你是否有想起些什么呢..没错，就是 Swift 中非常强大的 switch，我们来看看 switch 的几种常见用法吧：

###### 可以判等的类型的判断


```swift
let password = "akfuv(3"
switch password {
    case "akfuv(3": print("密码通过")
    default:        print("验证失败")
}
```
##### 对 Optional 的判断

```swift
let num: Int? = nil
switch num {
    case nil: print("没值")
    default:  print("\(num!)")
}
```
##### 对范围的判断

```swift

let x = 0.5
switch x {
    case -1.0...1.0: print("区间内")
    default: print("区间外")
}
```

**这并不是巧合。没错，Swift 的 switch 就是使用了 ~= 操作符进行模式匹配，case 指定的模式作为左参数输入，而等待匹配的被 switch 的元素作为操作符的右侧参数。只不过这个调用是由 Swift 隐式地完成的。于是我们可以发挥想象的地方就很多了，比如在 switch 中做 case 判断的时候，我们完全可以使用我们自定义的模式匹配方法来进行判断，有时候这会让代码变得非常简洁，具有条理。我们只需要按照需求重载 ~= 操作符就行了，接下来我们通过一个使用正则表达式做匹配的例子加以说明。
首先我们要做的是重载 ~= 操作符，让它接受一个 NSRegularExpression 作为模式，去匹配输入的 String：**


```swift
func ~=(pattern: NSRegularExpression, input: String) -> Bool {
    return pattern.numberOfMatchesInString(input,
        options: [],
        range: NSRange(location: 0, length: input.characters.count)) > 0
}
```

1. 然后为了简便起见，我们再添加一个将字符串转换为 NSRegularExpression 的操作符 (当然也可以使用 StringLiteralConvertible，但是它不是这个 tip 的主题，在此就先不使用它了)：

```swift
prefix operator ~/ {}

prefix func ~/(pattern: String) -> NSRegularExpression {
    return NSRegularExpression(pattern: pattern, options: nil, error: nil)
}
```

* 现在，我们在 case 语句里使用正则表达式的话，就可以去匹配被 switch 的字符串了：

```swift

let contact = ("http://onevcat.com", "onev@onevcat.com")

let mailRegex: NSRegularExpression
let siteRegex: NSRegularExpression

mailRegex = 
    try ~/"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$"
siteRegex = 
    try ~/"^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$"

switch contact {
    case (siteRegex, mailRegex): print("同时拥有有效的网站和邮箱")
    case (_, mailRegex): print("只拥有有效的邮箱")
    case (siteRegex, _): print("只拥有有效的网站")
    default: print("嘛都没有")
}

// 输出
// 同时拥有网站和邮箱

```

### ...和..<

1. 在很多脚本语言中 (比如 Perl 和 Ruby)，都有类似 0..3 或者 0...3 这样的 Range 操作符，用来简单地指定一个从 X 开始连续计数到 Y 的范围。
2. 这个特性不论在哪个社区，都是令人爱不释手的写法，Swift 中将其光明正大地 "借用" 过来，也就不足为奇了。
3. 最基础的用法当然还是在两边指定数字，0...3 就表示从 0 开始到 3 为止并包含 3 这个数字的范围，我们将其称为全闭合的范围操作；而在某些时候 (比如操作数组的 index 时)，我们更常用的是不包括最后一个数字的范围。这在 Swift 中被用一个看起来有些奇怪，但是表达的意义很清晰的操作符来定义，写作 0..<3 -- 都写了小于号了，自然是不包含最后的 3 的意思咯。
4. 对于这样得到的数字的范围，我们可以对它进行 for...in 的访问：


```swift
for i in 0...3 {
    print(i, terminator: "")
}

//输出 0123
```

**如果你认为 ... 和 ..< 只有这点内容的话，就大错特错了。我们可以仔细看看 Swift 中对着两个操作符的定义 (为了清晰，我稍微更改了一下它们的次序)：**


```swift
/// Forms a closed range that contains both `minimum` and `maximum`.
func ...<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos)
        -> Range<Pos>

/// Forms a closed range that contains both `start` and `end`.
/// Requres: `start <= end`
func ...<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos)
        -> Range<Pos>


/// Forms a half-open range that contains `minimum`, but not
/// `maximum`.
func ..<<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos)
        -> Range<Pos>

/// Forms a half-open range that contains `start`, but not
/// `end`.  Requires: `start <= end`
func ..<<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos)
        -> Range<Pos>


/// Returns a closed interval from `start` through `end`
func ...<T : Comparable>(start: T, end: T) -> ClosedInterval<T>

/// Returns a half-open interval from `start` to `end`
func ..<<T : Comparable>(start: T, end: T) -> HalfOpenInterval<T>
```

1. 不难发现，其实这几个方法都是支持泛型的。除了我们常用的输入 Int 或者 Double，返回一个 Range 以外，这个操作符还有一个接受 Comparable 的输入，并返回 ClosedInterval 或 HalfOpenInterval 的重载。
2. 在 Swift 中，除了数字以外另一个实现了 Comparable 的基本类型就是 String。也就是说，我们可以通过 ... 或者 ..< 来连接两个字符串。一个常见的使用场景就是检查某个字符是否是合法的字符。比如想确认一个单词里的全部字符都是小写英文字母的话，可以这么做：


```swift
let test = "helLo"
let interval = "a"..."z"
for c in test.characters {
    if !interval.contains(String(c)) {
        print("\(c) 不是小写字母")
    }
}

// 输出
// L 不是小写字母
```

* 在日常开发中，我们可能会需要确定某个字符是不是有效的 ASCII 字符，和上面的例子很相似，我们可以使用 \0...~ 这样的 ClosedInterval 来进行 (\0 和 ~ 分别是 ASCII 的第一个和最后一个字符)。

### ANYCLASS，元类型和 .SELF

* 在 Swift 中能够表示 “任意” 这个概念的除了 Any 和 AnyObject 以外，还有一个 AnyClass。AnyClass 在 Swift 中被一个 typealias 所定义：


```swift
typealias AnyClass = AnyObject.Type
```

1. 通过 AnyObject.Type 这种方式所得到是一个元类型 (Meta)。在声明时我们总是在类型的名称后面加上 .Type，比如 A.Type 代表的是 A 这个类型的类型。也就是说，我们可以声明一个元类型来存储 A 这个类型本身，而在从 A 中取出其类型时，我们需要使用到 .self：


```swift
class A {

}

let typeA: A.Type = A.self
```

**了解了这个基础之后，我们就明白 AnyObject.Type，或者说 AnyClass 所表达的东西其实并没有什么奇怪，就是任意类型本身。所以，上面对于 A 的类型的取值，我们也可以强制让它是一个 AnyClass：**


```swift
class A {

}

let typeA: AnyClass = A.self
```

**这样，要是 A 中有一个类方法时，我们就可以通过 typeA 来对其进行调用了：**


```swift
class A {
    class func method() {
        print("Hello")
    }
}

let typeA: A.Type = A.self
typeA.method()

// 或者
let anyClass: AnyClass = A.self
(anyClass as! A.Type).method()
```

* 也许你会问，这样做有什么意义呢，我们难道不是可以直接使用 A.method() 来调用么？没错，对于单个独立的类型来说我们完全没有必要关心它的元类型，但是元类型或者元编程的概念可以变得非常灵活和强大，这在我们编写某些框架性的代码时会非常方便。
* 比如我们想要传递一些类型的时候，就不需要不断地去改动代码了。在下面的这个例子中虽然我们是用代码声明的方式获取了 MusicViewController 和 AlbumViewController 的元类型，但是其实这一步骤完全可以通过读入配置文件之类的方式来完成的。而在将这些元类型存入数组并且传递给别的方法来进行配置这一点上，元类型编程就很难被替代了：


```swift
class MusicViewController: UIViewController {

}

class AlbumViewController: UIViewController {

}

let usingVCTypes: [AnyClass] = [MusicViewController.self,
    AlbumViewController.self]

func setupViewControllers(vcTypes: [AnyClass]) {
    for vcType in vcTypes {
        if vcType is UIViewController.Type {
            let vc = (vcType as! UIViewController.Type).init()
            print(vc)
        }

    }
}

setupViewControllers(usingVCTypes)
```

1. 这么一来，我们完全可以搭好框架，然后用 DSL 的方式进行配置，就可以在不触及 Swift 编码的情况下，很简单地完成一系列复杂操作了。
2. 另外，在 Cocoa API 中我们也常遇到需要一个 AnyClass 的输入，这时候我们也应该使用 .self 的方式来获取所需要的元类型，例如在注册 tableView 的 cell 的类型的时候：


```swift
self.tableView.registerClass(
    UITableViewCell.self, forCellReuseIdentifier: "myCell")
```

### 接口和类方法中的 SELF

**我们在看一些接口的定义时，可能会注意到出现了首字母大写的 Self 出现在类型的位置上：**


```swfit
protocol IntervalType {
    //...

    /// Return `rhs` clamped to `self`.  The bounds of the result, even
    /// if it is empty, are always within the bounds of `self`
    func clamp(intervalToClamp: Self) -> Self

    //...
}
```

1. 比如上面这个 IntervalType 的接口定义了一个方法，接受实现该接口的自身的类型，并返回一个同样的类型。
2. 这么定义是因为接口其实本身是没有自己的上下文类型信息的，在声明接口的时候，我们并不知道最后究竟会是什么样的类型来实现这个接口，Swift 中也不能在接口中定义泛型进行限制。而在声明接口时，我们希望在接口中使用的类型就是实现这个接口本身的类型的话，就需要使用 Self 进行指代。
3. 但是在这种情况下，Self 不仅指代的是实现该接口的类型本身，也包括了这个类型的子类。从概念上来说，Self 十分简单，但是实际实现一个这样的方法却稍微要转个弯。为了说明这个问题，我们假设要实现一个 Copyable 的接口，满足这个接口的类型需要返回一个和接受方法调用的实例相同的拷贝。一开始我们可能考虑的接口是这样的


```swift
protocol Copyable {
    func copy() -> Self
}
```

* 这是很直接明了的，它应该做的是创建一个和接受这个方法的对象同样的东西，然后将其返回，返回的类型不应该发生改变，所以写为 Self。然后开始尝试实现一个 MyClass 来满足这个接口：


```swift
class MyClass: Copyable {

    var num = 1

    func copy() -> Self {
        // TODO: 返回什么？
        // return
    }
}
```

**我们一开始的时候可能会写类似这样的代码：**


```swift
这是错误代码
func copy() -> Self {
    let result = MyClass()
    result.num = num
    return result
}
```

1. 但是显然类型是有问题的，因为该方法要求返回一个抽象的、表示当前类型的 Self，但是我们却返回了它的真实类型 MyClass，这导致了无法编译。也许你会尝试把方法声明中的 Self 改为 MyClass，这样声明就和实际返回一致了，但是很快你会发现这样的话，实现的方法又和接口中的定义不一样了，依然不能编译。
2. 为了解决这个问题，我们在这里需要的是通过一个和当前上下文 (也就是和 MyClass) 无关的，又能够指代当前类型的方式进行初始化。希望你还能记得我们在对象类型中所提到的 dynamicType，这里我们就可以使用它来做初始化，以保证方法与当前类型上下文无关，这样不论是 MyClass 还是它的子类，都可以正确地返回合适的类型满足 Self 的要求




```swift
func copy() -> Self {
    let result = self.dynamicType.init()
    result.num = num
    return result
}
```

1. 但是很不幸，单单是这样还是无法通过编译，编译器提示我们如果想要构建一个 Self 类型的对象的话，需要有 required 关键字修饰的初始化方法，
2. 这是因为 Swift 必须保证当前类和其子类都能响应这个 init 方法。另一个解决的方案是在当前类类的声明前添加 final 关键字，告诉编译器我们不再会有子类来继承这个类型。在这个例子中，我们选择添加上 required 的 init 方法。最后，MyClass 类型是这样的：


```swift

class MyClass: Copyable {

    var num = 1

    func copy() -> Self {
        let result = self.dynamicType.init()
        result.num = num
        return result
    }

    required init() {

    }
}
```

**我们可以通过测试来验证一下行为的正确性：**


```swift
let object = MyClass()
object.num = 100

let newObject = object.copy()
object.num = 1

print(object.num)     // 1
print(newObject.num)  // 100
```
**而对于 MyClass 的子类，copy() 方法也能正确地返回子类的经过拷贝的对象了。

另一个可以使用 Self 的地方是在类方法中，使用起来也十分相似，核心就在于保证子类也能返回恰当的类型。**

### 动态类型和多方法

1. Swift 中我们虽然可以通过 dynamicType 来获取一个对象的动态类型 (也就是运行时的实际类型，而非代码指定或编译器看到的类型)。但是在使用中，Swift 现在却是不支持多方法的，也就是说，不能根据对象在动态时的类型进行合适的重载方法调用。
2. 举个例子来说，在 Swift 里我们可以重载同样名字的方法，而只需要保证参数类型不同：


```swift
class Pet {}
class Cat: Pet {}
class Dog: Pet {}

func printPet(pet: Pet) {
    print("Pet")
}

func printPet(cat: Cat) {
    print("Meow")
}

func printPet(dog: Dog) {
    print("Bark")
}
```

* 在对这些方法进行调用时，编译器将帮助我们找到最精确的匹配：
        
```Swift
printPet(Cat()) // Meow
printPet(Dog()) // Bark
printPet(Pet()) // Pet
```
* 对于 Cat 或者 Dog 的实例，总是会寻找最合适的方法，而不会去调用一个通用的父类 Pet 的方法。这一切的行为都是发生在编译时的，如果我们写了下面这样的代码：


```Swift
func printThem(pet: Pet, _ cat: Cat) {
    printPet(pet)
    printPet(cat)
}

printThem(Dog(), Cat())

// 输出：
// Pet
// Meow
```

* 打印时的 Dog() 的类型信息并没有被用来在运行时选择合适的 printPet(dog: Dog) 版本的方法，而是被忽略掉，并采用了编译期间决定的 Pet 版本的方法。因为 Swift 默认情况下是不采用动态派发的，因此方法的调用只能在编译时决定。
* 要想绕过这个限制，我们可能需要进行通过对输入类型做判断和转换：


```Swift
func printThem(pet: Pet, _ cat: Cat) {
    if let aCat = pet as? Cat {
        printPet(aCat)
    } else if let aDog = pet as? Dog {
        printPet(aDog)
    }
    printPet(cat)
}

// 输出：
// Bark
// Meow
```

### 属性观察

1. 属性观察 (Property Observers) 是 Swift 中一个很特殊的特性，利用属性观察我们可以在当前类型内监视对于属性的设定，并作出一些响应。Swift 中为我们提供了两个属性观察的方法，它们分别是 willSet 和 didSet。
2. 使用这两个方法十分简单，我们只要在属性声明的时候添加相应的代码块，就可以对将要设定的值和已经设置的值进行监听了：


```Swift
class MyClass {
    var date: NSDate {
        willSet {
            let d = date
            print("即将将日期从 \(d) 设定至 \(newValue)")
        }

        didSet {
            print("已经将日期从 \(oldValue) 设定至 \(date)")
        }
    }

    init() {
        date = NSDate()
    }
}

let foo = MyClass()
foo.date = foo.date.dateByAddingTimeInterval(10086)

// 输出
// 即将将日期从 2014-08-23 12:47:36 +0000 设定至 2014-08-23 15:35:42 +0000
// 已经将日期从 2014-08-23 12:47:36 +0000 设定至 2014-08-23 15:35:42 +0000
```

1. 在 willSet 和 didSet 中我们分别可以使用 newValue 和 oldValue 来获取将要设定的和已经设定的值。属性观察的一个重要用处是作为设置值的验证，比如上面的例子中我们不希望 date 超过当前时间的一年以上的话，我们可以将 didSet 修改一下：



```Swift
class MyClass {
    let oneYearInSecond: NSTimeInterval = 365 * 24 * 60 * 60
    var date: NSDate {

        //...

        didSet {
            if (date.timeIntervalSinceNow > oneYearInSecond) {
                print("设定的时间太晚了！")
                date = NSDate().dateByAddingTimeInterval(oneYearInSecond)
            }
            print("已经将日期从 \(oldValue) 设定至 \(date)")
        }
    }

    //...
}
```

* 更改一下调用，我们就能看到效果：


```Swift
// 365 * 24 * 60 * 60 = 31_536_000
foo.date = foo.date.dateByAddingTimeInterval(100_000_000)

// 输出
// 即将将日期从 2014-08-23 13:24:14 +0000 设定至 2017-10-23 23:10:54 +0000
// 设定的时间太晚了！
// 已经将日期从 2014-08-23 13:24:14 +0000 设定至 2015-08-23 13:24:14 +0000
```

*  初始化方法对属性的设定，以及在 willSet 和 didSet 中对属性的再次设定都不会再次触发属性观察的调用，一般来说这会是你所需要的行为，可以放心使用能够。
*  我们知道，在 Swift 中所声明的属性包括存储属性和计算属性两种。
*  其中存储属性将会在内存中实际分配地址对属性进行存储，而计算属性则不包括背后的存储，只是提供 set 和 get 两种方法。
*  在同一个类型中，属性观察和计算属性是不能同时共存的。也就是说，想在一个属性定义中同时出现 set 和 willSet 或 didSet 是一件办不到的事情。
*  计算属性中我们可以通过改写 set 中的内容来达到和 willSet 及 didSet 同样的属性观察的目的。如果我们无法改动这个类，又想要通过属性观察做一些事情的话，可能就需要子类化这个类，并且重写它的属性了。
*  重写的属性并不知道父类属性的具体实现情况，而只从父类属性中继承名字和类型，因此在子类的重载属性中我们是可以对父类的属性任意地添加属性观察的，而不用在意父类中到底是存储属性还是计算属性：


```Swift
class A {
    var number :Int {
        get {
            print("get")
            return 1
        }

        set {print("set")}
    }
}

class B: A {
    override var number: Int {
        willSet {print("willSet")}
        didSet {print("didSet")}
    }
}
```

* 调用 number 的 set 方法可以看到工作的顺序


```Swift
let b = B()
b.number = 0

// 输出
// get
// willSet
// set
// didSet
```

* set 和对应的属性观察的调用都在我们的预想之中。这里要注意的是 get 首先被调用了一次。这是因为我们实现了 didSet，didSet 中会用到 oldValue，而这个值需要在整个 set 动作之前进行获取并存储待用，否则将无法确保正确性。如果我们不实现 didSet 的话，这次 get 操作也将不存在。

### FINAL

1. final 关键字可以用在 class，func 或者 var 前面进行修饰，表示不允许对该内容进行继承或者重写操作。
2. 这个关键字的作用和 C# 中的 sealed 相同，而 sealed 其实在 C# 算是一个饱受争议的关键字。有一派程序员认为，类似这样的禁止继承和重写的做法是非常有益的，它可以更好地对代码进行版本控制，得到更佳的性能，以及使代码更安全。因此他们甚至认为语言应当是默认不允许继承的，只有在显式地指明可以继承的时候才能子类化。
3. 在这里我不打算对这样的想法做出判断或者评价，虽然上面列举的优点都是事实，但是另一个事实是不论是 Apple 或者微软，以及世界上很多其他语言都没有作出默认不让继承和重写的决定。带着“这不是一个可以滥用的特性”的观点，我们来看看在写 Swift 的时候可能会在什么情况下使用 final。
4. 权限控制
5. 给一段代码加上 final 就意味着编译器向你作出保证，这段代码不会再被修改；同时，这也意味着你认为这段代码已经完备并且没有再被进行继承或重写的必要，因此这往往会是一个需要深思熟虑的决定。在 Cocoa 开发中 app 开发是一块很大的内容，对于大多数我们自己完成的面向 app 开发代码，其实不太会提供给别人使用，这种情况下即使是将所有自己写的代码标记为 final 都是一件无可厚非的事情 (但我并不是在鼓励这么做) -- 因为在需要的任何时候你都可以将这个关键字去掉以恢复其可继承性。而在开发给其他开发者使用的库时，就必须更深入地考虑各种使用场景和需求了。
6. 一般来说，不希望被继承和重写会有这几种情况：
7. 类或者方法的功能确实已经完备了
8. 对于很多的辅助性质的工具类或者方法，可能我们会考虑加上 final。这样的类有一个比较大的特点，是很可能只包含类方法而没有实例方法。比如我们很难想到一种情况需要继承或重写一个负责计算一段字符串的 MD5 或者 AES 加密解密的工具类。这种工具类和方法的算法是经过完备验证和固定的，使用者只需要调用，而相对来说不可能有继承和重写的需求。
9. 这种情况很多时候遵循的是以往经验和主观判断，而单个的开发者的判断其实往往并不可靠。遇到希望把某个自己开发的类或者方法标为 final 的时候，去找几个富有经验的开发者，问问他们的意见或者看法，应该是一个比较靠谱的做法。
10. 子类继承和修改是一件危险的事情
11. 在子类继承或重写某些方法后可能做一些破坏性的事情，导致子类或者父类部分也无法正常工作的情况。举个例子，在某个公司管理的系统中我们对员工按照一定规则进行编号，这样通过编号我们能迅速找到任一员工。而假如我们在子类中重写了这个编号方法，很可能就导致基类中的依赖员工编号的方法失效。在这类情况下，将编号方法标记为 final 以确保稳定，可能是一种更好的做法。
12. 为了父类中某些代码一定会被执行
13. 有时候父类中有一些关键代码是在被继承重写后必须执行的 (比如状态配置，认证等等)，否则将导致运行时候的错误。而在一般的方法中，如果子类重写了父类方法，是没有办法强制子类方法一定去调用相同的父类方法的。在 Objective-C 的时候我们可以通过指定 __attribute__((objc_requires_super)) 这样的属性来让编译器在子类没有调用父类方法时抛出警告。在 Swift 中对原来的很多 attribute 的支持现在还缺失中，为了达到类似的目的，我们可以使用一个 final 的方法，在其中进行一些必要的配置，然后再调用某个需要子类实现的方法，以确保正常运行：


```Swift
class Parent {

    final func method() {
        print("开始配置")
        // ..必要的代码

        methodImpl()

        // ..必要的代码
        print("结束配置")
    }

    func methodImpl() {
        fatalError("子类必须实现这个方法")
        // 或者也可以给出默认实现
    }

}

class Child: Parent {
    override func methodImpl() {
        //..子类的业务逻辑
    }
}
```
* 这样，无论如何我们如何使用 method，都可以保证需要的代码一定被运行过，而同时又给了子类继承和重写自定义具体实现的机会。
* 性能考虑
* 使用 final 的另一个重要理由是可能带来的性能改善。因为编译器能够从 final 中获取额外的信息，因此可以对类或者方法调用进行额外的优化处理。但是这个优势在实际表现中可能带来的好处其实就算与 Objective-C 的动态派发相比也十分有限，因此在项目还有其他方面可以优化 (一般来说会是算法或者图形相关的内容导致性能瓶颈) 的情况下，并不建议使用将类或者方法转为 final 的方式来追求性能的提升。

### lazy 修饰符和 lazy 方法

* 延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值，也是一种浪费。
* 在其他语言 (包括 Objective-C) 中延时加载的情况是很常见的。我们在第一次访问某个属性时，判断这个属性背后的存储是否已经存在，如果存在则直接返回，如果不存在则说明是首次访问，那么就进行初始化并存储后再返回。这样我们可以把这个属性的初始化时刻推迟，与包含它的对象的初始化时刻分开，以达到提升性能的目的。以 Objective-C 举个例子 (虽然这里既没有费时操作，也不会因为使用延时加载而造成什么性能影响，但是作为一个最简单的例子，可以很好地说明问题)：


```Swift
// ClassA.h
@property (nonatomic, copy) NSString *testString;

// ClassA.m
- (NSString *)testString {
     if (!_testString) {
         _testString = @"Hello";
        NSLog(@"只在首次访问输出");
     }
     return _testString;
}
```

1. 在初始化 ClassA 对象后，_testString 是 nil。只有当首次访问 testString 属性时 getter 方法会被调用，并检查如果还没有初始化的话，就进行赋值。为了方便确认，我们还在赋值时打印了一句 log。我们之后再多次访问这个属性的话，因为 _testString 已经有值，因此将直接返回。
2. 在 Swift 中我们使用在变量属性前加 lazy 关键字的方式来简单地指定延时加载。比如上面的的代码我们在 Swift 中重写的话，会是这样：


```Swift
class ClassA {
    lazy var str: String = {
        let str = "Hello"
        print("只在首次访问输出")
        return str
    }()
}
```

* 我们在使用 lazy 作为属性修饰符时，只能声明属性是变量。另外我们需要显式地指定属性类型，并使用一个可以对这个属性进行赋值的语句来在首次访问属性时运行。如果我们多次访问这个实例的 str 属性的话，可以看到只有一次输出。
* 为了简化，我们如果不需要做什么额外工作的话，也可以对这个 lazy 的属性直接写赋值语句：
**lazy var str: String = "Hello"**

>相比起在 Objective-C 中的实现方法，现在的 lazy 使用起来要方便得多。

>另外一个不太引起注意的是，在 Swift 的标准库中，我们还有一组 lazy 方法，它们的定义是这样的：
>

```Swift
func lazy<S : SequenceType>(s: S) -> LazySequence<S>

func lazy<S : CollectionType where S.Index : RandomAccessIndexType>(s: S)
                -> LazyRandomAccessCollection<S>

func lazy<S : CollectionType where S.Index : BidirectionalIndexType>(s: S)
                -> LazyBidirectionalCollection<S>

func lazy<S : CollectionType where S.Index : ForwardIndexType>(s: S)
                -> LazyForwardCollection<S>
```

1. 这些方法可以配合像 map 或是 filter 这类接受闭包并进行运行的方法一起，让整个行为变成延时进行的。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：


```Swift
let data = 1...3
let result = data.map {
    (i: Int) -> Int in
    print("正在处理 \(i)")
    return i * 2
}

print("准备访问结果")
for i in result {
    print("操作后结果为 \(i)")
}

print("操作完毕")
// 正在处理 1
// 正在处理 2
// 正在处理 3
// 准备访问结果
// 操作后结果为 2
// 操作后结果为 4
// 操作后结果为 6
// 操作完毕
```

**而如果我们先进行一次 lazy 操作的话，我们就能得到延时运行版本的容器：**


```Swift
let data = 1...3
let result = data.lazy.map {
    (i: Int) -> Int in
    print("正在处理 \(i)")
    return i * 2
}

print("准备访问结果")
for i in result {
    print("操作后结果为 \(i)")
}

print("操作完毕")
// 准备访问结果
// 正在处理 1
// 操作后结果为 2
// 正在处理 2
// 操作后结果为 4
// 正在处理 3
// 操作后结果为 6
// 操作完毕
<!--对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。-->
```
### REFLECTION 和 MIRROR

> 熟悉 Java 的读者可能会知道反射 (Reflection)。这是一种在运行时检测、访问或者修改类型的行为的特性。一般的静态语言类型的结构和方法的调用等都需要在编译时决定，开发者能做的很多时候只是使用控制流 (比如 if 或者 switch) 来决定做出怎样的设置或是调用哪个方法。而反射特性可以让我们有机会在运行的时候通过某些条件实时地决定调用的方法，或者甚至向某个类型动态地设置甚至加入属性及方法，是一种非常灵活和强大的语言特性。

>Objective-C 中我们不太会经常提及到 “反射” 这样的词语，因为 Objective-C 的运行时比一般的反射还要灵活和强大。可能很多读者已经习以为常的像是通过字符串生成类或者 selector，并且进而生成对象或者调用方法等，其实都是反射的具体的表现。而在 Swift 中其实就算抛开 Objective-C 的运行时的部分，在纯 Swift 范畴内也存在有反射相关的一些内容，只不过相对来说功能要弱得多。

>因为这部分内容并没有公开的文档说明，所以随时可能发生变动，或者甚至存在今后被从 Swift 的可调用标准库中去掉的可能 (Apple 已经干过这种事情，最早的时候 Swift 中甚至有隐式的类型转换 __conversion，但因为太过危险，而被彻底去除了。现在隐式转换必须使用字面量转换的方式进行了)。在实际的项目中，也不建议使用这种没有文档说明的 API，不过有时候如果能稍微知道 Swift 中也存在这样的可能性的话，也许会有帮助 (也指不定哪天 Apple 就扔出一个完整版的反射功能呢)。

>Swift 中所有的类型都实现了 _Reflectable，这是一个内部接口，我们可以通过 _reflect 来获取任意对象的一个镜像，这个镜像对象包含类型的基本信息，在 Swift 2.0 之前，这是对某个类型的对象进行探索的一种方法。在 Swift 2.0 中，这些方法已经从公开的标准库中移除了，取而代之，我们可以使用 Mirror 类型来做类似的事情：



```Swift
struct Person {
    let name: String
    let age: Int
}

let xiaoMing = Person(name: "XiaoMing", age: 16)
let r = Mirror(reflecting: xiaoMing) // r 是 MirrorType

print("xiaoMing 是 \(r.displayStyle!)")

print("属性个数:\(r.children.count)")
for i in r.children.startIndex..<r.children.endIndex {
    print("属性名:\(r.children[i].0!)，值:\(r.children[i].1)")
}

// 输出：
// xiaoMing 是 Struct
// 属性个数:2
// 属性名:name，值:XiaoMing
// 属性名:age，值:16
```

**通过 Mirror 初始化得到的结果中包含的元素的描述都被集合在 children 属性下，如果你有心可以到 Swift 标准库中查找它的定义，它实际上是一个 Child 的集合，而 Child 则是一对键值的多元组：**

**public typealias Child = (label: String?, value: Any)
public typealias Children = AnyForwardCollection<Child>**

1. AnyForwardCollection 是遵守 CollectionType 接口的，因此我们可以简单地使用 count 来获取元素的个数，而对于具体的代表属性的多元组，则使用下标进行访问。在对于我们的例子中，每个 Child 都是具有两个元素的多元组，其中第一个是属性名，第二个是这个属性所存储的值。需要特别注意的是，这个值有可能是多个元素组成嵌套的形式 (例如属性值是数组或者字典的话，就是这样的形式)。
2. 如果觉得一个个打印太过于麻烦，我们也可以简单地使用 dump 方法来通过获取一个对象的镜像并进行标准输出的方式将其输出出来。比如对上面的对象 xiaoMing：

```Swift
dump(xiaoMing)
// 输出：
// ▿ Person
//  - name: XiaoMing
//  - age: 16
```

* 在这里因为篇幅有限，而且这部分内容很可能随着版本而改变，我们就不再一一介绍 Mirror 的更详细的内容了。有兴趣的读者不妨打开 Swift 的定义文件并找到这个接口，里面对每个属性和方法的作用有非常详细的注释。
* 对于一个从对象反射出来的 Mirror，它所包含的信息是完备的。也就是说我们可以在运行时通过 Mirror 的手段了解一个 Swift 类型 (当然 NSObject 类也可以) 的实例的属性信息。该特性最容易想到的应用的特性就是为任意 model 对象生成对应的 JSON 描述。我们可以对等待处理的对象的 Mirror 值进行深度优先的访问，并按照属性的 valueType 将它们归类对应到不同的格式化中。
* 另一个常见的应用场景是类似对 Swift 类型的对象做像 Objective-C 中 KVC 那样的 valueForKey: 的取值。通过比较取到的属性的名字和我们想要取得的 key 值就行了，非常简单：


```Swift
func valueFrom(object: Any, key: String) -> Any? {
    let mirror = Mirror(reflecting: object)

    for i in mirror.children.startIndex..<mirror.children.endIndex {
        let (targetKey, targetMirror) = mirror.children[i]
        if key == targetKey {
            return targetMirror
        }
    }

    return nil
}

// 接上面的 xiaoMing
if let name = valueFrom(xiaoMing, key: "name") as? String {
    print("通过 key 得到值: \(name)")
}

// 输出：
// 通过 key 得到值: XiaoMing
```

>在现在的版本中，Swift 的反射特性并不是非常强大，我们只能对属性进行读取，还不能对其设定，不过我们有希望能在将来的版本中获得更为强大的反射特性。另外需要特别注意的是，虽然理论上将反射特性应用在实际的 app 制作中是可行的，但是这一套机制设计的最初目的是用于 REPL 环境和 Playground 中进行输出的。所以我们最好遵守 Apple 的这一设定，只在 REPL 和 Playground 中用它来对一个对象进行深层次的探索，而避免将它用在 app 制作中 -- 因为你永远不知道什么时候它们就会失效或者被大幅改动。


### 隐式解包 OPTIONAL

> 相对于普通的 Optional 值，在 Swift 中我们还有一种特殊的 Optional，在对它的成员或者方法进行访问时，编译器会帮助我们自动进行解包，这就是 ImplicitlyUnwrappedOptional。在声明的时候，我们可以通过在类型后加上一个感叹号 (!) 这个语法糖来告诉编译器我们需要一个可以隐式解包的 Optional 值

**var maybeObject: MyClass!**

> 首先需要明确的是，隐式解包的 Optional 本质上与普通的 Optional 值并没有任何不同，只是我们在对这类变量的成员或方法进行访问的时候，编译器会自动为我们在后面插入解包符号 !，也就是说，对于一个隐式解包的下面的两种写法是等效的：



```Swift
var maybeObject: MyClass! = MyClass()
maybeObject!.foo()
maybeObject.foo()
```

1. 我们知道，如果 maybeObject 是 nil 的话那么这两种不加检查的写法的调用都会导致程序崩溃。而如果 maybeObject 是普通的 Optional 的话，我们就只能使用第一种显式地加感叹号的写法，这能提醒我们也许应该使用 if let 的 Optional Binding 的形式来处理。
2. 而对隐式解包来说，后一种写法看起来就好像我们操作的 maybeObject 确实是 MyClass 类的实例，不需要对其检查就可以使用 (当然实际上这不是真的)。为什么一向以安全著称的 Swift 中会存在隐式解包并可以写出让人误认为能直接访问的这种危险写法呢？
3. 一切都是历史的错。因为 Objective-C 中 Cocoa 的所有类型变量都可以指向 nil 的，有一部分 Cocoa 的 API 中在参数或者返回时即使被声明为具体的类型，但是还是有可能在某些特定情况下是 nil，而同时也有另一部分 API 永远不会接收或者返回 nil。
4. 在 Objective-C 时，这两种情况并没有被加以区别，因为 Objective-C 里向 nil 发送消息并不会有什么不良影响。在将 Cocoa API 从 Objective-C 转为 Swift 的 module 声明的自动化工具里，是无法判定是否存在 nil 的可能的，因此也无法决定哪些类型应该是实际的类型，而哪些类型应该声明为 Optional。
5. 在这种自动化转换中，最简单粗暴的应对方式是全部转为 Optional，然后让使用者通过 Optional Binding 来判断并使用。
6. 虽然这是最安全的方式，但对使用者来说是一件非常麻烦的事情，我猜不会有人喜欢每次用个 API 就在 Optional 和普通类型之间转来转去。这时候，隐式解包的 Optional 就作为一个妥协方案出现了。使用隐式解包 Optional 的最大好处是对于那些我们能确认的 API 来说，我们可直接进行属性访问和方法调用，会很方便。但是需要牢记在心的是，隐式解包不意味着 “这个变量不会是 nil，你可以放心使用” 这种暗示，只能说 Swift 通过这个特性给了我们一种简便但是危险的使用方式罢了。
7. 另外，其实在 Apple 的不断修改 (我相信这是一件消耗大量人月的手工工作) 下，在 Swift 的正式版本中，已经没有太多的隐式解包的 API 了。
8. 最近 Objective-C 中又加入了像是 nonnull 和 nullable 这样的修饰符，这样一来，那些真正有可能为 nil 的返回可以被明确定义为普通的 Optional 值，而那些不会是 Optional 的值，也根据情况转换为了确定的类型。现在比较常见的隐式解包的 Optional 就只有使用 Interface Builder 时建立的 IBOutlet 了：


```Swift
@IBOutlet weak var button: UIButton!
```

> 如果没有连接 IB 的话，对 button 的直接访问会导致应用崩溃，这种情况和错误在调试应用时是很容易被发现的问题。在我们的代码的其他部分，还是少用这样的隐式解包的 Optional 为好，很多时候多写一个 Optional Binding 就可以规避掉不少应用崩溃的风险。


### 多重 OPTIONAL

1. Optional 可以说是 Swift 的一大特色，它完全解决了 “有” 和 “无” 这两个困扰了 Objective-C 许久的哲学概念，也使得代码安全性得到了很大的增加。但是一个陷阱 -- 或者说一个很容易让人迷惑的概念 -- 也随之而来，那就是多重的 Optional。
2. 在深入讨论之前，可以让我们先看看 Optional 是什么。很多读者应该已经知道，我们使用的类型后加上 ? 的语法只不过是 Optional 类型的语法糖，而实际上这个类型是一个 enum：


```Swift
enum Optional<T> : _Reflectable, NilLiteralConvertible {
    case None
    case Some(T)

    //...
}
```

* 在这个定义中，对 T 没有任何限制，也就是说，我们是可以在 Optional 中装入任意东西的，甚至也包括 Optional 对象自身。打个形象的比方，如果我们把 Optional 比作一个盒子，实际具体的 String 或者 Int 这样的值比作糖果的话，当我们打开一个盒子 (unwrap) 时，可能的结果会有三个 -- 空气，糖果，或者另一个盒子。
* 空气和糖果都很好理解，也十分直接。但是对于盒子中的盒子，有时候使用时就相当容易出错。特别是在和各种字面量转换混用的时候需要特别注意。
* 对于下面这种形式的写法：


```Swift
var string: String? = "string"
var anotherString: String?? = string
```

> 我们可以很明白地知道 anotherString 是 Optinal<Optional<String>>。但是除开将一个 Optional 值赋给多重 Optional 以外，我们也可以将直接的字面量值赋给它：

*var literalOptional: String?? = "string"*

* 这种情况还好，根据类型推断我们只能将 Optional<String> 放入到 literalOptional 中，所以可以猜测它与上面提到的 anotherString 是等效的。但是如果我们是将 nil 赋值给它的话，情况就有所不同了。考虑下面的代码：


```Swift
var aNil: String? = nil

var anotherNil: String?? = aNil
var literalNil: String?? = nil
```

1. anotherNil 和 literalNil 是不是等效的呢？答案是否定的。anotherNil 是盒子中包了一个盒子，打开内层盒子的时候我们会发现空气；但是 literalNil 是盒子中直接是空气。使用中一个最显著的区别在于：


```Swift
if let a = anotherNil {
    print("anotherNil")
}

if let b = literalNil {
    print("literalNil")
}
```

1. 这样的代码只能输出 anotherNil。
2. 另一个值得注意的地方时在Playground 中运行时，或者在用 lldb 进行调试时，直接使用 po 指令打印 Optional 值的话，为了看起来方便，lldb 会将要打印的 Optional 进行展开。如果我们直接打印上面的 anotherNil 和 literalNil，得到的结果都是 nil


```Swift
(lldb) po anotherNil
nil

(lldb) po literalNil
nil
```

> 如果我们遇到了多重 Optional 的麻烦的时候，这显然对我们是没有太大帮助的。我们可以使用 fr v -R 命令来打印出变量的未加工过时的信息，就像这样：


```Swift
(lldb) fr v -R anotherNil
(Swift.Optional<Swift.Optional<Swift.String>>)
    anotherNil = Some {
    ... 中略
}
(lldb) fr v -R literalNil
(Swift.Optional<Swift.Optional<Swift.String>>)
    literalNil = None {
    ... 中略
}
```

*这样我们就能清晰地分辨出两者的区别了。*

### OPTIONAL MAP

> 我们经常会对 Array 类型使用 map 方法，这个方法能对数组中的所有元素应用某个规则，然后返回一个新的数组。我们可以在 CollectionType 的 extension 中找到这个方法的定义：


```Swift
extension CollectionType {
    public func map<T>(@noescape transform: 
                    (Self.Generator.Element) -> T) -> [T]

    //...
}
```


```Swift
let arr = [1,2,3]
let doubled = arr.map{
    $0 * 2
}

print(doubled)
// 输出：
// [2,4,6]
```

1. 这很方便，而且在其他一些语言里 map 可以说是很常见也很常用的一个语言特性了。因此当这个特性出现在 Swift 中时，也赢得了 iOS/Mac 开发者们的欢迎。
2. 现在假设我们有个需求，要将某个 Int? 乘 2。一个合理的策略是如果这个 Int? 有值的话，就取出值进行乘 2 的操作，如果是 nil 的话就直接将 nil 赋给结果。依照这个策略，我们可以写出如下代码

```Swift
let num: Int? = 3

var result: Int?
if let realNum = num {
    result = realNum * 2
} else {
    result = nil
}
```
* 其实我们有更优雅简洁的方式，那就是使用 Optional 的 map。对的，不仅在 Array 或者说 CollectionType 里可以用 map，如果我们仔细看过 Optional 的声明的话，会发现它也有一个 map 方法


```Swift
public enum Optional<T> :
    _Reflectable, NilLiteralConvertible {

    //...

    /// If `self == nil`, returns `nil`.  Otherwise, returns `f(self!)`.
    public func map<U>(@noescape f: (T) -> U) -> U?

    //...
}
```

1. 这个方法能让我们很方便地对一个 Optional 值做变化和操作，而不必进行手动的解包工作。输入会被自动用类似 Optinal Binding 的方式进行判断，如果有值，则进入 f 的闭包进行变换，并返回一个 U?；如果输入就是 nil 的话，则直接返回值为 nil 的 U?。
2. 有了这个方法，上面的代码就可以大大简化，而且 result 甚至可以使用常量值：

```Swift
let num: Int? = 3
let result = num.map {
    $0 * 2
}

// result 为 {Some 6}
```

1. 如果您了解过一些函数式编程的概念，可能会知道这正符合函子 (Functor) 的概念。不论是 Array 还是 Optional，它们拥有一个同样名称的 map 函数并不是命名上的偶然。函子指的是可以被某个函数作用，并映射为另一组结果，而这组结果也是函子的值。

### PROTOCOL EXTENSION

1. Swift 2 中引入了一个非常重要的特性，那就是 protocol extension。在 Swift 1.x 中，extension 仅只能作用在实际的类型上 (也就是 class, struct 等等)，而不能扩展一个 protocol。
2. 在 Swift 中，标准库的功能基本都是基于 protocol 来实现的，举个最简单的例子，我们每天使用的 Array 就是遵守了 CollectionType 这个 protocol 的。CollectionType 可以说是 Swift 中非常重要的接口，除了 Array 以外，像是 Dictionary 和 Set 也都实现了这个接口所定义的内容。
3. 在 protocol 不能被扩展的时候，当我们想要为实现了某个接口的所有类型添加一些另外的共通的功能时，会非常麻烦。一个很好的例子是 Swift 1.x 时像是 map 或者 filter 这样的函数。大体来说，我们有两种思路进行添加：
4. 第一种方式是在接口中定义这个方法，然后在所有实现了这个接口的类型中都去实现一遍。每有一个这样的类型，我们就需要写一份类似甚至相同的方法，这显然是不可取的，不仅麻烦，而且完全没有可维护性。另一种方法是在全局范围实现一个接受该 protocol 的实例的方法，相比于前一种方式，我们只需要维护一份代码，显然要好不少，但是缺点在于在全局作用域中引入了只和特定 protocol 有关的东西，这并不符合代码设计的美学。作为妥协，Apple 在 Swift 1.x 中采用的是后一种，也就是全局方法，如果你尝试寻找的话，可以在 Swift 1.x 的标准库的全局 scope 中找到像是 map 和 filter 这样的方法。
5. 在 Swift 2 中这个问题被彻底解决了。现在我们可以对一个已有的 protocol 进行扩展，而扩展中实现的方法将作为实现扩展的类型的默认实现。也就是说，假设我们有下面的 protocol 声明，以及一个对该接口的扩展：


```Swift
protocol MyProtocol {
    func method()
}

extension MyProtocol {
    func method() {
        print("Called")
    }
}
```

* 在具体的实现这个接口的类型中，即使我们什么都不写，也可以编译通过。进行调用的话，会直接使用 extension 中的实现：


```Swift
struct MyStruct: MyProtocol {

}

MyStruct().method()
// 输出：
// Called in extension
```

* 当然，如果我们需要在类型中进行其他实现的话，可以像以前那样在具体类型中添加这个方法：


```Swift
struct MyStruct: MyProtocol {
    func method() {
        print("Called in struct")
    }
}

MyStruct().method()
// 输出：
// Called in struct
```

> 也就是说，protocol extension 为 protocol 中定义的方法提供了一个默认的实现。有了这个特性以后，之前被放在全局环境中的接受 CollectionType 的 map 方法，就可以被移动到 CollectionType 的接口扩展中去了：

```Swift
extension CollectionType {
    public func map<T>(@noescape transform: (Self.Generator.Element) -> T) -> [T]
    //...
}
```

* 在日常开发中，另一个可以用到 protocol extension 的地方是 optional 的接口方法。通过提供 protocol 的 extension，我们为 protocol 提供了默认实现，这相当于变相将 protocol 中的方法设定为了 optional。关于这个，我们在可选接口和接口扩展一节中已经讲述过，就不再重复了。
* 对于 protocol extension 来说，有一种会非常让人迷惑的情况，就是在接口的扩展中实现了接口里没有定义的方法时的情况。举个例子，比如我们定义了这样的一个接口和它的一个扩展：


```Swift
protocol A1 {
    func method1() -> String
}

struct B1: A1 {
    func method1() -> String {
        return "hello"
    }
}
```
*在使用的时候，无论我们将实例的类型为 A1 还是 B1，因为实现只有一个，所以没有任何疑问，调用方法时的输出都是 “hello”：*


```Swift
let b1 = B1() // b1 is B1
b1.method1()
// hello

let a1: A1 = B1()
// a1 is A1
a1.method1()
// hello
```

* 但是如果在接口里只定义了一个方法，而在接口扩展中实现了额外的方法的话，事情就变得有趣起来了。考虑下面这组接口和它的扩展：


```Swift
protocol A2 {
    func method1() -> String
}

extension A2 {
    func method1() -> String {
        return "hi"
    }

    func method2() -> String {
        return "hi"
    }
}
```

* 扩展中除了实现接口定义的 method1 之外，还定义了一个接口中不存在的方法 method2。我们尝试来实现这个接口：

```Swift
struct B2: A2 {
    func method1() -> String {
        return "hello"
    }

    func method2() -> String {
        return "hello"
    }
}
```

1. B2 中实现了 method1 和 method2。接下来，我们尝试初始化一个 B2 对象，然后对这两个方法进行调用：


```Swift
let b2 = B2()

b2.method1() // hello
b2.method2() // hello
```

2. 结果在我们的意料之中，虽然在 protocol extension 中已经实现了这两个方法，但是它们只是默认的实现，我们在具体实现接口的类型中可以对默认实现进行覆盖，这非常合理。但是如果我们稍作改变，在上面的代码后面继续添加：


```Swift
let a2 = b2 as A2

a2.method1() // hello
a2.method2() // hi
```

3. a2 和 b2 是同一个对象，只不过我们通过 as 告诉编译器我们在这里需要的类型是 A2。但是这时候在这个同样的对象上调用同样的方法调用却得到了不同的结果，发生了什么？
4. 我们可以看到，对 a2 调用 method2 实际上是接口扩展中的方法被调用了，而不是 a2 实例中的方法被调用。我们不妨这样来理解：对于 method1，因为它在 protocol 中被定义了，因此对于一个被声明为遵守接口的类型的实例 (也就是对于 a2) 来说，可以确定实例必然实现了 method1，我们可以放心大胆地用动态派发的方式使用最终的实现 (不论它是在类型中的具体实现，还是在接口扩展中的默认实现)；但是对于 method2 来说，我们只是在接口扩展中进行了定义，没有任何规定说它必须在最终的类型中被实现。在使用时，因为 a2 只是一个符合 A2 接口的实例，编译器对 method2 唯一能确定的只是在接口扩展中有一个默认实现，因此在调用时，无法确定安全，也就不会去进行动态派发，而是转而编译期间就确定的默认实现。
5. 也许在这个例子中你会觉得无所谓，因为实际中估计并不会有人将一个已知类型实例转回接口类型。但是要考虑到如果你的一些泛型 API 中有类似的直接拿到一个接口类型的结果的时候，调用它的扩展方法时就需要特别小心了：一般来说，如果有这样的需求的话，我们可以考虑将这个接口类型再转回实际的类型，然后进行调用。
6. 整理一下相关的规则的话：
7. 如果类型推断得到的是实际的类型那么类型中的实现将被调用；如果类型中没有实现的话，那么接口扩展中的默认实现将被使用如果类型推断得到的是接口，而不是实际类型并且方法在接口中进行了定义，那么类型中的实现将被调用；如果类型中没有实现，那么接口扩展中的默认实现被使用否则 (也就是方法没有在接口中定义)，扩展中的默认实现将被调用

### where 和模式匹配

1. “where 关键字在 Swift 中非常强大，但是往往容易被忽视。在这一节中，我们就来整理看看 where 有哪些使用场合吧。
2. 首先是 switch 语句中，我们可以使用 where 来限定某些条件 case”


```Swift
“let name = ["王小二","张三","李四","王二小"]

name.forEach {
    switch $0 {
    case let x where x.hasPrefix("王"):
        print("\(x)是笔者本家")
    default:
        print("你好，\($0)")
    }
}

// 输出：
// 王小二是笔者本家
// 你好，张三
// 你好，李四”
//王二小是笔者家
```

* “这可以说是模式匹配的标准用法，对 case 条件进行限定可以让我们更灵活地使用 switch 语句。
* 在 if let 或者是 for 中我们也可以使用 where 来做类似的条件限定：”

```Swift
“let num: [Int?] = [48, 99, nil]
num.forEach {
    if let score = $0 where score > 60 {
        print("及格啦 - \(score)")
    } else {
        print(":(")
    }
}
// 输出：
// :(
// 及格啦 - 99
// :(

for score in num where score > 60 {
    print("及格啦 - \(score)")
}
// 输出”
//及格啦
```

* “这两种使用的方式都可以用额外的 if 来替代，这里只不过是让我们的代码更加易读了。也有一些场合是只有使用 where 才能准确表达的，比如我们在泛型中想要对方法的类型进行限定的时候。比如在标准库里对 RawRepresentable 接口定义 != 运算符定义时：”


```Swift
“/// Returns `true` iff `lhs.rawValue != rhs.rawValue`.
public func !=<T : RawRepresentable 
                where T.RawValue : Equatable>(lhs: T, rhs: T) -> Bool”

``` 

* “这里限定了 T.RawValue 必须要遵守 Equatable 接口，这样我们才能通过对比 lhs 和 rhs 的 rawValue 是否相等，进而判断这两个 RawRepresentable 值是否相等。如果没有 where 的保证的话，下面的代码就无法编译。同时，我们也限定了那些 RawValue 无法判等的 RawRepresentable 类型不能进行判等。”


```Swift
“/// Returns `true` iff `lhs.rawValue != rhs.rawValue`.
public func !=<T : RawRepresentable 
                where T.RawValue : Equatable>(lhs: T, rhs: T) -> Bool {
    return lhs.rawValue != rhs.rawValue
}”

```

* “在 Swift 2.0 中，引入了 protocol extension。在有些时候，我们会希望一个接口扩展的默认实现只在某些特定的条件下适用，这时我们就可以用 where 关键字来进行限定。标准库中的接口扩展大量使用了这个技术来进行限定，比如 SequenceType 的 sort 方法就被定义在这样一个类型限制的接口扩展中：”


```Swift
“extension SequenceType where Self.Generator.Element : Comparable {
    public func sort() -> [Self.Generator.Element]
}”

“let sortableArray: [Int] = [3,1,2,4,5]
let unsortableArray: [AnyObject?] = ["Hello", 4, nil]

sortableArray.sort()
// [1,2,3,4,5]

unsortableArray.sort()
// 无法编译
// note: expected an argument list of type 
// '(@noescape (Self.Generator.Element, Self.Generator.Element) -> Bool)'
// 这意味着 Swift 尝试使用带有闭包的 `sort` 方法，并期望你输入一种排序方式”

```

### INDIRECT 和嵌套 ENUM


> 在涉及到一些数据结构的经典理论和模型 (没错，就是链表，树和图) 时，我们往往会用到嵌套的类型。比如链表，在 Swift 中，我们可以这样来定义一个单向链表：在涉及到一些数据结构的经典理论和模型 (没错，就是链表，树和图) 时，我们往往会用到嵌套的类型。比如链表，在 Swift 中，我们可以这样来定义一个单向链表：


```Swift
class Node<T> {
    let value: T?
    let next: Node<T>?

    init(value: T?, next: Node<T>?) {
        self.value = value
        self.next = next
    }
}

let list = Node(value: 1,
             next: Node(value: 2,
               next: Node(value: 3,
                 next: Node(value: 4, next: nil))))
// 单向链表：1 -> 2 -> 3 -> 4
```

1. 看起来还不错，但是这样的形式在表达空节点的时候并不十分理想。
2. 我们不得不借助于 nil 来表达空节点，但是事实上空节点和 nil 并不是等价的。
3. 另外，如果我们想表达一个空链表的话，要么需要把 list 设置为 Optional，要么把 Node 里的 value 以及 next 都设为 nil，这导致描述中存在歧义，我们不得不去做一些人为的约定来表述这样的情况，这在算法描述中是十分致命的。
4. 在 Swift 2 中，我们现在可以使用嵌套的 enum 了 -- 而这在 Swift 1.x 里是编译器所不允许的。我们用 enum 来重新定义链表结构的话，会是下面这个样子：


```Swift
indirect enum LinkedList<Element: Comparable> {
    case Empty
    case Node(Element, LinkedList<Element>)
}
let linkedList = LinkedList.Node(1, .Node(2, .Node(3, .Node(4, .Empty))))
// 单项链表：1 -> 2 -> 3 -> 4
```

1. 在 enum 的定义中嵌套自身对于 class 这样的引用类型来说没有任何问题，但是对于像 struct 或者 enum 这样的值类型来说，普通的做法是不可行的。
2. 我们需要在定义前面加上 indirect 来提示编译器不要直接在值类型中直接嵌套。用 enum 表达链表的好处在于，我们可以清晰地表示出空节点这一定义，这在像 Swift 这样类型十分严格的语言中是很有帮助的。比如我们可以寥寥数行就轻易地实现链表节点的删除方法，在 enum 中添加：


```Swift
func linkedListByRemovingElement(element: Element)
                            -> LinkedList<Element> {
    guard case let .Node(value, next) = self else {
        return .Empty
    }
    return value == element ?
        next : LinkedList.Node(value, next.linkedListByRemovingElement(element))
}

let result = linkedList.linkedListByRemovingElement(2)
print(result)
// 1 -> 3 -> 4
```
## 从 Objective-C/C 到 Swift

### SELECTOR

> @selector 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Objective-C 时 selector 非常常用，从设定 target-action，到自举询问是否响应某个方法，再到指定接受通知时需要调用的方法等等，都是由 selector 来负责的。在 Objective-C 里生成一个 selector 的方法一般是这个样子的：


```Swift
-(void) callMe {
    //...
}

-(void) callMeWithParam:(id)obj {
    //...
}

SEL someMethod = @selector(callMe);
SEL anotherMethod = @selector(callMeWithParam:);

// 或者也可以使用 NSSelectorFromString
// SEL someMethod = NSSelectorFromString(@"callMe");
// SEL anotherMethod = NSSelectorFromString(@"callMeWithParam:");
```

1. 一般为了方便，很多人会选择使用 @selector，但是如果要追求灵活的话，可能会更愿意使用 NSSelectorFromString 的版本 -- 因为我们可以在运行时动态生成字符串，从而通过方法的名字来调用到对应的方法。
2. 在 Swift 中没有 @selector 了，取而代之，从 Swift 2.2 开始我们使用 #selector 来从暴露给 Objective-C 的代码中获取一个 selector。类似地，在 Swift 里对应原来 SEL 的类型是一个叫做 Selector 的结构体。像上面的两个例子在 Swift 中等效的写法是：


```Swift
func callMe() {
    //...
}

func callMeWithParam(obj: AnyObject!) {
    //...
}

let someMethod = #selector(callMe)
let anotherMethod = #selector(callMeWithParam(_:))
```

1. 和 Objective-C 时一样，记得在 callMeWithParam 后面加上冒号 (:)，这才是完整的方法名字。多个参数的方法名也和原来类似，是这个样子：


```Swift
func turnByAngle(theAngle: Int, speed: Float) {
    //...
}

let method = #selector(turnByAngle(_:speed:))
```

* 最后需要注意的是，selector 其实是 Objective-C runtime 的概念，如果你的 selector 对应的方法只在 Swift 中可见的话 (也就是说它是一个 Swift 中的 private 方法)，在调用这个 selector 时你会遇到一个 unrecognized selector 错误：

### 实例方法的动态调用

1. 在 Swift 中有一类很有意思的写法，可以让我们不直接使用实例来调用这个实例上的方法，而是通过类型取出这个类型的某个实例方法的签名，然后再通过传递实例来拿到实际需要调用的方法。比如我们有这样的定义：


```Swift
class MyClass {
    func method(number: Int) -> Int {
        return number + 1
    }
}
```
* 想要调用 method 方法的话，最普通的使用方式是生成 MyClass 的实例，然后用 .method 来调用它：

```Swift
let object = MyClass()
let result = object.method(1)

// result = 2
```

* 这就限定了我们只能够在编译的时候就决定 object 实例和对应的方法调用。其实我们还可以使用刚才说到的方法，将上面的例子改写为：


```Swift
let f = MyClass.method
let object = MyClass()
let result = f(object)(1)
```
* 这种语法看起来会比较奇怪，但是实际上并不复杂。Swift 中可以直接用 Type.instanceMethod 的语法来生成一个可以柯里化的方法。如果我们观察 f 的类型 (Alt + 单击)，可以知道它是：


```Swift
f: MyClass -> (Int) -> Int
```

* 其实对于 Type.instanceMethod 这样的取值语句，实际上刚才
let f = MyClass.method

* 做的事情是类似于下面这样的字面量转换：


```Swift
let f = { (obj: MyClass) in obj.method }
```

* 这下就不难理解为什么上面的调用方法可以成立了。

这种方法只适用于实例方法，对于属性的 getter 或者 setter 是不能用类似的写法的。另外，如果我们遇到有类型方法的名字冲突时：


```Swift
class MyClass {
    func method(number: Int) -> Int {
        return number + 1
    }

    class func method(number: Int) -> Int {
        return number
    }
}
```

* 如果不加改动，MyClass.method 将取到的是类型方法，如果我们想要取实例方法的话，可以显式地加上类型声明加以区别。这种方式不仅在这里有效，在其他大多数名字有歧义的情况下，都能很好地解决问题：


```Swift
let f1 = MyClass.method
// class func method 的版本

let f2: Int -> Int = MyClass.method
// 和 f1 相同

let f3: MyClass -> Int -> Int = MyClass.method
// func method 的柯里化版本
```
#### 单例

* 单例是一个在 Cocoa 中很常用的模式了。对于一些希望能在全局方便访问的实例，或者在 app 的生命周期中只应该存在一个的对象，我们一般都会使用单例来存储和访问。在 Objective-C 中单例的公认的写法类似下面这样：


```Object-c
@implementation MyManager
+ (id)sharedManager {
    static MyManager * staticInstance = nil;
    static dispatch_once_t onceToken;

    dispatch_once(&onceToken, ^{
        staticInstance = [[self alloc] init];
    });
    return staticInstance;
}
@end
```

* 使用 GCD 中的 dispatch_once_t 可以保证里面的代码只被调用一次，以此保证单例在线程上的安全

因为在 Swift 中可以无缝直接使用 GCD，所以我们可以很方便地把类似方式的单例用 Swift 进行改写：


```Swift
class MyManager {
    class var sharedManager : MyManager {
        struct Static {
            static var onceToken : dispatch_once_t = 0
            static var staticInstance : MyManager? = nil
        }

        dispatch_once(&Static.onceToken) {
            Static.staticInstance = MyManager()
        }

        return Static.staticInstance!
    }
}
```
* 因为 Swift 1.2 之前并不支持存储类型的类属性，所以我们需要使用一个 struct 来存储类型变量。

这样的写法当然没什么问题，但是在 Swift 里我们其实有一个更简单的保证线程安全的方式，那就是 let。把上面的写法简化一下，可以变成：


```Swift
class MyManager {
    class var sharedManager : MyManager {
        struct Static {
            static let sharedInstance : MyManager = MyManager()
        }

        return Static.sharedInstance
    }
}
```

* 还有另一种更受大家欢迎，并被认为是 Swift 1.2 之前的最佳实践的做法。由于 Swift 1.2 之前 class 不支持存储式的 property，我们想要使用一个只存在一份的属性时，就只能将其定义在全局的 scope 中。值得庆幸的是，在 Swift 中是有访问级别的控制的，我们可以在变量定义前面加上 private 关键字，使这个变量只在当前文件中可以被访问。这样我们就可以写出一个没有嵌套的，语法上也更简单好看的单例了：


```Swift
private let sharedInstance = MyManager()

class MyManager  {
    class var sharedManager : MyManager {
        return sharedInstance
    }
}
```

> Swift 1.2 中的改进
> Swift 1.2 之前还不支持例如 static let 和 static var 这样的存储类变量。但是在 1.2 中 Swift 添加了类变量的支持，因此单例可以进一步简化。
将上面全局的 sharedInstance 拿到 class 中，这样结构上就更紧凑和合理了。


```Swift
class MyManager  {
    static let sharedInstance = MyManager()
    private init() {}
}
```

* 这种写法不仅简洁，而且保证了单例的独一无二。在初始化类变量的时候，Apple 将会把这个初始化包装在一次 swift_once_block_invoke 中，以保证它的唯一性。另外，我们在这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 MyManager 实例，也保证了类型单例的唯一性。如果你需要的是类似 defaultManager 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 init 方法。

### 条件编译

* 在 C 系语言中，可以使用 #if 或者 #ifdef 之类的编译条件分支来控制哪些代码需要编译，而哪些代码不需要。Swift 中没有宏定义的概念，因此我们不能使用 #ifdef 的方法来检查某个符号是否经过宏定义。但是为了控制编译流程和内容，Swift 还是为我们提供了几种简单的机制来根据需求定制编译内容的。
* 首先是 #if 这一套编译标记还是存在的，使用的语法也和原来没有区别：


```Swift
#if <condition>

#elseif <condition>

#else

#endif
```

* 当然，#elseif 和 #else 是可选的。
* 但是这几个表达式里的 condition 并不是任意的。Swift 内建了几种平台和架构的组合，来帮助我们为不同的平台编译不同的代码，具体地：
* 注意这些方法和参数都是大小写敏感的。举个例子，如果我们统一我们在 iOS 平台和 Mac 平台的关于颜色的 API 的话，一种可能的方法就是配合 typealias 进行条件编译：


```Swift
#if os(OSX)
    typealias Color = NSColor
#else
    typealias Color = UIColor
#endif
```

1. 另外对于 arch() 的参数需要说明的是 arm 和 arm64 两项分别对应 32 位 CPU 和 64 位 CPU 的真机情况，而对于模拟器，相应地 32 位设备的模拟器和 64 位设备的模拟器所对应的分别是 i386 和 x86_64，它们也是需要分开对待的。
2. 另一种方式是对自定义的符号进行条件编译，比如我们需要使用同一个 target 完成同一个 app 的收费版和免费版两个版本，并且希望在点击某个按钮时收费版本执行功能，而免费版本弹出提示的话，可以使用类似下面的方法：


```Swift
@IBAction func someButtonPressed(sender: AnyObject!) {
    #if FREE_VERSION
        // 弹出购买提示，导航至商店等
    #else
        // 实际功能
    #endif
}
```

1. 在这里我们用 FREE_VERSION 这个编译符号来代表免费版本。为了使之有效，我们需要在项目的编译选项中进行设置，在项目的 Build Settings 中，找到 Swift Compiler - Custom Flags，并在其中的 Other Swift Flags 加上 -D FREE_VERSION 就可以了。

### 编译标记

1. 在 Objective-C 中，我们经常在代码中插入 #param 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。这在单个文件方法较多的时候进行快速定位非常有用。
2. 在 Swift 中也有类似的方式，我们可以在代码合适的地方添加 // MARK: 这样的标记 (注意大写)，并在后面接上名称，Xcode 将在代码中寻找这样的注释，然后以粗体标签的形式将名称显示在导航栏中。比如：
3. 另外我们还可以在冒号的后面加一个横杠 -，这样在导航中会在这个位置再多显示一条横线，隔开各个部分，会显得更加清晰。
4. 除了 // MARK: 以外，Xcode 还支持另外几种标记，它们分别是 // TODO: 和 // FIXME:。和 MARK 不同的是，另外两个标记在导航栏中不仅会显示后面跟着的名字或者说明，而且它们本身也会被显示出来，用来提示还未完成的工作或者需要修正的地方。这样在阅读源代码时首先看一看导航栏中的标记，就可以对当前文件有个大致的了解了。
5. 以前在 Objective-C 中还有一个很常用的编译标记，那就是 #warning，一个 #warning 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。这个特性当前的 Swift 版本里还没有对应的方案。希望 Apple 能在接下来的版本中会加入一些类似的标记，像这个样子：


```Swift
// WARNING: Add your API key here
```
### @UIAPPLICATIONMAIN

1. 因为 Cocoa 开发环境已经在新建一个项目时帮助我们进行很多配置，这导致了不少刚接触 iOS 的开发者都存在基础比较薄弱的问题，其中一个最显著的现象就是很多人无法说清一个 app 启动的流程。程序到底是怎么开始的，AppDelegate 到底是什么，xib 或者 storyboard 是怎么被加载到屏幕上的？这一系列的问题虽然在开发中我们不会每次都去关心和自己配置，但是如果能进行一些了解的话对于程序各个部分的职责的明确会很有帮助。
2. 在 C 系语言中，程序的入口都是 main 函数。对于一个 Objective-C 的 iOS app 项目，在新建项目时， Xcode 将帮我们准备好一个 main.m 文件，其中就有这个 main 函数：


```object-c
int main(int argc, char * argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil,
                   NSStringFromClass([AppDelegate class]));
    }
}
```

3. 在这里我们调用了 UIKit 的 UIApplicationMain 方法。这个方法将根据第三个参数初始化一个 UIApplication 或其子类的对象并开始接收事件 (在这个例子中传入 nil，意味使用默认的 UIApplication)。最后一个参数指定了 AppDelegate 类作为应用的委托，它被用来接收类似 didFinishLaunching 或者 didEnterBackground 这样的与应用生命周期相关的委托方法。另外，虽然这个方法标明为返回一个 int，但是其实它并不会真正返回。它会一直存在于内存中，直到用户或者系统将其强制终止。
4. 了解了这些后，我们就可以来看看 Swift 的项目中对应的情况了。新建一个 Swift 的 iOS app 项目后，我们会发现所有文件中都没有一个像 Objective-C 时那样的 main 文件，也不存在 main 函数。唯一和 main 有关系的是在默认的 AppDelegate 类的声明上方有一个 @UIApplicationMain 的标签
5. 不说可能您也已经猜到，这个标签做的事情就是将被标注的类作为委托，去创建一个 UIApplication 并启动整个程序。在编译的时候，编译器将寻找这个标记的类，并自动插入像 main 函数这样的模板代码。我们可以试试看把 @UIApplicationMain 去掉会怎么样：
6. 说明找不到 main 函数了。
7. 在一般情况下，我们并不需要对这个标签做任何修改，但是当我们如果想要使用 UIApplication 的子类而不是它本身的话，我们就需要对这部分内容 “做点手脚” 了。
8. 刚才说到，其实 Swift 的 app 也是需要 main 函数的，只不过默认情况下是 @UIApplicationMain 帮助我们自动生成了而已。和 C 系语言的 main.c 或者 main.m 文件一样，Swift 项目也可以有一个名为 main.swift 特殊的文件。在这个文件中，我们不需要定义作用域，而可以直接书写代码。这个文件中的代码将作为 main 函数来执行。比如我们在删除 @UIApplicationMain 后，在项目中添加一个 main.swift 文件，然后加上这样的代码：


```object-c
UIApplicationMain(Process.argc, Process.unsafeArgv, nil,
    NSStringFromClass(AppDelegate))
```

9. 现在编译运行，就不会再出现错误了。当然，我们还可以通过将第三个参数替换成自己的 UIApplication 子类，这样我们就可以轻易地做一些控制整个应用行为的事情了。比如将 main.swift 的内容换成：


```Swift
import UIKit

class MyApplication: UIApplication {
    override func sendEvent(event: UIEvent!) {
        super.sendEvent(event)
        print("Event sent: \(event)");
    }
}

UIApplicationMain(Process.argc, Process.unsafeArgv,
    NSStringFromClass(MyApplication), NSStringFromClass(AppDelegate))
```

### @OBJC 和 DYNAMIC

1. 虽然说 Swift 语言的初衷是希望能摆脱 Objective-C 的沉重的历史包袱和约束，但是不可否认的是经过了二十多年的洗礼，Cocoa 框架早就烙上了不可磨灭的 Objective-C 的印记。无数的第三方库是用 Objective-C 写成的，这些积累无论是谁都不能小觑。因此，在最初的版本中，Swift 不得不考虑与 Objective-C 的兼容。
2. Apple 采取的做法是允许我们在同一个项目中同时使用 Swift 和 Objective-C 来进行开发。其实一个项目中的 Objective-C 文件和 Swift 文件是处于两个不同世界中的，为了让它们能相互联通，我们需要添加一些桥梁。
3. 首先通过添加 {product-module-name}-Bridging-Header.h 文件，并在其中填写想要使用的头文件名称，我们就可以很容易地在 Swift 中使用 Objective-C 代码了。Xcode 为了简化这个设定，甚至在 Swift 项目中第一次导入 Objective-C 文件时会主动弹框进行询问是否要自动创建这个文件，可以说是非常方便。
4. 但是如果想要在 Objective-C 中使用 Swift 的类型的时候，事情就复杂一些。如果是来自外部的框架，那么这个框架与 Objective-C 项目肯定不是处在同一个 target 中的，我们需要对外部的 Swift module 进行导入。这个其实和使用 Objective-C 的原来的 Framework 是一样的，对于一个项目来说，外界框架是由 Swift 写的还是 Objective-C 写的，两者并没有太大区别。我们通过使用 2013 年新引入的 @import 来引入 module：

> @import MySwiftKit;

5. 之后就可以正常使用这个 Swift 写的框架了。
如果想要在 Objective-C 里使用的是同一个项目中的 Swift 的源文件的话，可以直接导入自动生成的头文件 {product-module-name}-Swift.h 来完成。比如项目的 target 叫做 MyApp 的话，我们就需要在 Objective-C 文件中写

> #import "MyApp-Swift.h"

6. 但这只是故事的开始。Objective-C 和 Swift 在底层使用的是两套完全不同的机制，Cocoa 中的 Objective-C 对象是基于运行时的，它从骨子里遵循了 KVC (Key-Value Coding，通过类似字典的方式存储对象信息) 以及动态派发 (Dynamic Dispatch，在运行调用时再决定实际调用的具体实现)。而 Swift 为了追求性能，如果没有特殊需要的话，是不会在运行时再来决定这些的。也就是说，Swift 类型的成员或者方法在编译时就已经决定，而运行时便不再需要经过一次查找，而可以直接使用。
7. 显而易见，这带来的问题是如果我们要使用 Objective-C 的代码或者特性来调用纯 Swift 的类型时候，我们会因为找不到所需要的这些运行时信息，而导致失败。解决起来也很简单，在 Swift 类型文件中，我们可以将需要暴露给 Objective-C 使用的任何地方 (包括类，属性和方法等) 的声明前面加上 @objc 修饰符。注意这个步骤只需要对那些不是继承自 NSObject 的类型进行，如果你用 Swift 写的 class 是继承自 NSObject 的话，Swift 会默认自动为所有的非 private 的类和成员加上 @objc。这就是说，对一个 NSObject 的子类，你只需要导入相应的头文件就可以在 Objective-C 里使用这个类了。
8. @objc 修饰符的另一个作用是为 Objective-C 侧重新声明方法或者变量的名字。虽然绝大部分时候自动转换的方法名已经足够好用 (比如会将 Swift 中类似 init(name: String) 的方法转换成 -initWithName:(NSString *)name 这样)，但是有时候我们还是期望 Objective-C 里使用和 Swift 中不一样的方法名或者类的名字，比如 Swift 里这样的一个类：


```Swift
class 我的类: NSObject {
    func 打招呼(名字: String) {
        print("哈喽，\(名字)")
    }
}

我的类().打招呼("小明")
```

> 注：在 Swift 2.0 中，Apple 在从 Swift 导出头文件时引入了一个叫做 SWIFT_CLASS_NAMED 的宏来对原来 Swift 中的内容进行标记。这个宏使用 LLVM 的标记来对目标类的类型做出了限制，但是同时引入了不允许非 ascii 编码的问题。下面的代码在 Swift 1.x 环境下可以通过，但是在 Swift 2 中会导致 “Parameter of 'swift_name' attribute must be an ASCII identifier string” 的编译错误，这应该是 Swift 2.0 中的一个预期之外的倒退。笔者已经向 Apple 提交了 bug 报告。关于这个问题的更多信息，可以参考 rdar://22737851 和这里的讨论。


9. Objective-C 的话是无法使用中文来进行调用的，因此我们必须使用 @objc 将其转为 ASCII 才能在 Objective-C 里访问：

```Swift
@objc(MyClass)
    class 我的类 {
        @objc(greeting:)
        func 打招呼(名字: String) {
            print("哈喽，\(名字)")
        }
    }
```

10. 这样，我们在 Objective-C 里就能调用 [[MyClass new] greeting:@"XiaoMing"] 这样的代码了 (虽然比起原来一点都不好玩了)。另外，正如上面所说的以及在 Selector 一节中所提到的，即使是 NSObject 的子类，Swift 也不会在被标记为 private 的方法或成员上自动加 @objc，以保证尽量不使用动态派发来提高代码执行效率。如果我们确定使用这些内容的动态特性的话，我们需要手动给它们加上 @objc 修饰。
11. 但是需要注意的是，添加 @objc 修饰符并不意味着这个方法或者属性会变成动态派发，Swift 依然可能会将其优化为静态调用。如果你需要和 Objective-C 里动态调用时相同的运行时特性的话，你需要使用的修饰符是 dynamic。一般情况下在做 app 开发时应该用不上，但是在施展一些像动态替换方法或者运行时再决定实现这样的 "黑魔法" 的时候，我们就需要用到 dynamic 修饰符了。在 KVO 一节中，我们提到了一个关于使用 dynamic 的实例。
12. 关于 Swift 和 Objective-C 混用的一个好消息是，随着 Swift 的发展，Apple 正在努力改善 SDK。在 Objective-C 中添加的 nonnull 和 nullable，以及泛型的数组和字典等，其实上都是为了使 SDK 更加适合用 Swift 来使用所做的努力，我们还是很有希望在不久的未来能够摆脱掉这些妥协和束缚的。

### 可选协议和协议扩展

* Objective-C 中的 protocol 里存在 @optional 关键字，被这个关键字修饰的方法并非必须要被实现。我们可以通过协议定义一系列方法，然后由实现协议的类选择性地实现其中几个方法。在 Cocoa API 中很多情况下协议方法都是可选的，这点和 Swift 中的 protocol 的所有方法都必须被实现这一特性完全不同。
* 那些如果没有实现则协议就无法正常工作的方法一般是必须的，而相对地像作为事件通知或者对非关键属性进行配置的方法一般都是可选的。最好的例子我想应该是 UITableViewDataSource 和 UITableViewDelegate。前者中有两个必要方法：

```Swift
-tableView:numberOfRowsInSection:
-tableView:cellForRowAtIndexPath:
```

* 分别用来计算和准备 tableView 的高度以及提供每一个 cell 的样式，而其他的像是返回 section 个数或者询问 cell 是否能被编辑的方法都有默认的行为，都是可选方法；后者 (UITableViewDelegate) 中的所有方法都是详细的配置和事件回传，因此全部都是可选的。

原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的。如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前以及协议方法之前加上 @objc。另外和 Objective-C 中的 @optional 不同，我们使用没有 @ 符号的关键字 optional 来定义可选方法：


```Swift
@objc protocol OptionalProtocol {
    @objc optional func optionalMethod()
}

```

* 另外，对于所有的声明，它们的前缀修饰是完全分开的。也就是说你不能像是在 Objective-C 里那样用一个 @optional 指定接下来的若干个方法都是可选的了，必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：

```Swift
@objc protocol OptionalProtocol {
    @objc optional func optionalMethod()  // 可选
    func necessaryMethod()          // 必须
    @objc optional func anotherOptionalMethod() // 可选
}

```
*  一个不可避免的限制是，使用 @objc 修饰的 protocol 就只能被 class 实现了，也就是说，对于 struct 和 enum 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 class 中的方法还必须也被标注为 @objc，或者整个类就是继承自 NSObject。这对我们写代码来说是一种[…]

“开的。也就是说你不能像是在 Objective-C 里那样用一个 @optional 指定接下来的若干个方法都是可选的了，必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：

```Swift
@objc protocol OptionalProtocol {
    @objc optional func optionalMethod()  // 可选
    func necessaryMethod()          // 必须
    @objc optional func anotherOptionalMethod() // 可选
}
```

*  一个不可避免的限制是，使用 @objc 修饰的 protocol 就只能被 class 实现了，也就是说，对于 struct 和 enum 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 class 中的方法还必须也被标注为 @objc，或者整个类就是继承自 NSObject。这对我们写代码来说是一种很让人郁闷的限制。


```Swift
“protocol OptionalProtocol {
    func optionalMethod()        // 可选
    func necessaryMethod()       // 必须
    func anotherOptionalMethod() // 可选
}

extension OptionalProtocol {
    func optionalMethod() {
        print("Implemented in extension")
    }

    func anotherOptionalMethod() {
        print("Implemented in extension")
    }
}

class MyClass: OptionalProtocol {
    func necessaryMethod() {
        print("Implemented in Class3")
    }

    func optionalMethod() {
        print("Implemented in Class3")
    }
}

let obj = MyClass()
obj.necessaryMethod() // Implemented in Class3
obj.optionalMethod()  // Implemented in Class3
obj.anotherOptionalMethod() // Implemented in extension”
```
### 内存管理，WEAK 和 UNOWNED

* 不管在什么语言里，内存管理的内容都很重要，所以我打算花上比其他 tip 长一些的篇幅仔细地说说这块内容。
* Swift 是自动管理内存的，这也就是说，我们不再需要操心内存的申请和分配。当我们通过初始化创建一个对象时，Swift 会替我们管理和分配内存。而释放的原则遵循了自动引用计数 (ARC) 的规则：当一个对象没有引用的时候，其内存将会被自动回收。这套机制从很大程度上简化了我们的编码，我们只需要保证在合适的时候将引用置空 (比如超过作用域，或者手动设为 nil 等)，就可以确保内存使用不出现问题。
* 但是，所有的自动引用计数机制都有一个从理论上无法绕过的限制，那就是循环引用 (retain cycle) 的情况。

##### 什么是循环引用

* 虽然我觉得循环引用这样的概念介绍不太应该出现在这本书中，但是为了更清晰地解释 Swift 中的循环引用的一般情况，这里还是简单进行说明。假设我们有两个类 A 和 B， 它们之中分别有一个存储属性持有对方：


```Swift

class A {
    let b: B
    init() {
        b = B()
        b.a = self
    }

    deinit {
        print("A deinit")
    }
}

class B {
    var a: A? = nil
    deinit {
        print("B deinit")
    }
}
```
* 在 A 的初始化方法中，我们生成了一个 B 的实例并将其存储在属性中。然后我们又将 A 的实例赋值给了 b.a。这样 a.b 和 b.a 将在初始化的时候形成一个引用循环。现在当有第三方的调用初始化了 A，然后即使立即将其释放，A 和 B 两个类实例的 deinit 方法也不会被调用，说明它们并没有被释放。


```Swift
var obj: A? = A()
obj = nil
// 内存没有释放
```

* 因为即使 obj 不再持有 A 的这个对象，b 中的 b.a 依然引用着这个对象，导致它无法释放。而进一步，a 中也持有着 b，导致 b 也无法释放。在将 obj 设为 nil 之后，我们在代码里再也拿不到对于这个对象的引用了，所以除非是杀掉整个进程，我们已经永远也无法将它释放了。多么悲伤的故事啊..

##### 在 Swift 里防止循环引用

* 为了防止这种人神共愤的悲剧的发生，我们必须给编译器一点提示，表明我们不希望它们互相持有。一般来说我们习惯希望 "被动" 的一方不要去持有 "主动" 的一方。在这里 b.a 里对 A 的实例的持有是由 A 的方法设定的，我们在之后直接使用的也是 A 的实例，因此认为 b 是被动的一方。可以将上面的 class B 的声明改为：


```Swift
class B {
    weak var a: A? = nil
    deinit {
        print("B deinit")
    }
}
```

* 在 var a 前面加上了 weak，向编译器说明我们不希望持有 a。这时，当 obj 指向 nil 时，整个环境中就没有对 A 的这个实例的持有了，于是这个实例可以得到释放。接着，这个被释放的实例上对 b 的引用 a.b 也随着这次释放结束了作用域，所以 b 的引用也将归零，得到释放。添加 weak 后的输出：


```Swift
A deinit
B deinit
```

* 可能有心的朋友已经注意到，在 Swift 中除了 weak 以外，还有另一个冲着编译器叫喊着类似的 "不要引用我" 的标识符，那就是 unowned。它们的区别在哪里呢？如果您是一直写 Objective-C 过来的，那么从表面的行为上来说 unowned 更像以前的 unsafe_unretained，而 weak 就是以前的 weak。用通俗的话说，就是 unowned 设置以后即使它原来引用的内容已经被释放了，它仍然会保持对被已经释放了的对象的一个 "无效的" 引用，它不能是 Optional 值，也不会被指向 nil。
* 如果你尝试调用这个引用的方法或者访问成员属性的话，程序就会崩溃。而 weak 则友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil (因此被标记为 @weak 的变量一定需要是 Optional 值)。关于两者使用的选择，Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。
* 我们结合实际编码中的使用来看看选择吧。日常工作中一般使用弱引用的最常见的场景有两个：
* 设置 delegate 时
* 在 self 属性存储为闭包时，其中拥有对 self 引用时
* 前者是 Cocoa 框架的常见设计模式，比如我们有一个负责网络请求的类，它实现了发送请求以及接收请求结果的任务，其中这个结果是通过实现请求类的 protocol 的方式来实现的，这种时候我们一般设置 delegate 为 weak：


```Swift
// RequestManager.swift
class RequestManager: RequestHandler {

    @objc func requestFinished() {
        print("请求完成")
    }

    func sendRequest() {
        let req = Request()
        req.delegate = self

        req.send()
    }
}

// Request.swift
@objc protocol RequestHandler {
    optional func requestFinished()
}

class Request {
    weak var delegate: RequestHandler!;

    func send() {
        // 发送请求
        // 一般来说会将 req 的引用传递给网络框架
    }

    func gotResponse() {
        // 请求返回
        delegate?.requestFinished?()
    }
}

```

* req 中以 weak 的方式持有了 delegate，因为网络请求是一个异步过程，很可能会遇到用户不愿意等待而选择放弃的情况。这种情况下一般都会将 RequestManager 进行清理，所以我们其实是无法保证在拿到返回时作为 delegate 的 RequestManager 对象是一定存在的。因此我们使用了 weak 而非 unowned，并在调用前进行了判断。

##### 闭包和循环引用

* 另一种闭包的情况稍微复杂一些：我们首先要知道，闭包中对任何其他元素的引用都是会被闭包自动持有的。如果我们在闭包中写了 self 这样的东西的话，那我们其实也就在闭包内持有了当前的对象。这里就出现了一个在实际开发中比较隐蔽的陷阱：如果当前的实例直接或者间接地对这个闭包又有引用的话，就形成了一个 self -> 闭包 -> self 的循环引用。最简单的例子是，我们声明了一个闭包用来以特定的形式打印 self 中的一个字符串：


```Swift
class Person {
    let name: String
    lazy var printName: ()->() = {
        print("The name is \(self.name)")
    }

    init(personName: String) {
        name = personName
    }

    deinit {
        print("Person deinit \(self.name)")
    }
}

var xiaoMing: Person? = Person(personName: "XiaoMing")
xiaoMing!.printName()
xiaoMing = nil
// 输出:
// The name is XiaoMing，没有被释放
```
* printName 是 self 的属性，会被 self 持有，而它本身又在闭包内持有 self，这导致了 xiaoMing 的 deinit 在自身超过作用域后还是没有被调用，也就是没有被释放。为了解决这种闭包内的循环引用，我们需要在闭包开始的时候添加一个标注，来表示这个闭包内的某些要素应该以何种特定的方式来使用。可以将 printName 修改为这样：


```Swift
lazy var printName: ()->() = {
    [weak self] in
    if let strongSelf = self {
        print("The name is \(strongSelf.name)")
    }
}
```

* 现在内存释放就正确了：

>// 输出:
// The name is XiaoMing
// Person deinit XiaoMing
如果我们可以确定在整个过程中 self 不会被释放的话，我们可以将上面的 weak 改为 unowned，这样就不再需要 strongSelf 的判断。但是如果在过程中 self 被释放了而 printName 这个闭包没有被释放的话 (比如 生成 Person 后，某个外部变量持有了 printName，随后这个 Persone 对象被释放了，但是 printName 已然存在并可能被调用)，使用 unowned 将造成崩溃。在这里我们需要根据实际的需求来决定是使用 weak 还是 unowned。

* 这种在闭包参数的位置进行标注的语法结构是将要标注的内容放在原来参数的前面，并使用中括号括起来。如果有多个需要标注的元素的话，在同一个中括号内用逗号隔开，举个例子：


```swift
// 标注前
{ (number: Int) -> Bool in
    //...
    return true
}

// 标注后
{ [unowned self, weak someObject] (number: Int) -> Bool in
    //...
    return true
}
```

### @AUTORELEASEPOOL

1. Swift 在内存管理上使用的是自动引用计数 (ARC) 的一套方法，在 ARC 中虽然不需要手动地调用像是 retain，release 或者是 autorelease 这样的方法来管理引用计数，但是这些方法还是都会被调用的 -- 只不过是编译器在编译时在合适的地方帮我们加入了而已。
2. 其中 retain 和 release 都很直接，就是将对象的引用计数加一或者减一。但是autorelease 就比较特殊一些，它会将接受该消息的对象放到一个预先建立的自动释放池 (auto release pool) 中，并在 自动释放池收到 drain 消息时将这些对象的引用计数减一，然后将它们从池子中移除 (这一过程形象地称为“抽干池子”)。
3. 在 app 中，整个主线程其实是跑在一个自动释放池里的，并且在每个主 Runloop 结束时进行 drain 操作。这是一种必要的延迟释放的方式，因为我们有时候需要确保在方法内部初始化的生成的对象在被返回后别人还能使用，而不是立即被释放掉。
4. 在 Objective-C 中，建立一个自动释放池的语法很简单，使用 @autoreleasepool 就行了。如果你新建一个 Objective-C 项目，可以看到 main.m 中就有我们刚才说到的整个项目的 autoreleasepool：


```object-c
int main(int argc, char * argv[]) {
    @autoreleasepool {
        int retVal = UIApplicationMain(
            argc,
            argv,
            nil,
            NSStringFromClass([AppDelegate class]));
        return retVal;
    }
}
```

5. 更进一步，其实 @autoreleasepool 在编译时会被展开为 NSAutoreleasePool，并附带 drain 方法的调用。
6. 而在 Swift 项目中，因为有了 @UIApplicationMain，我们不再需要 main 文件和 main 函数，所以原来的整个程序的自动释放池就不存在了。即使我们使用 main.swift 来作为程序的入口时，也是不需要自己再添加自动释放池的。
7. 但是在一种情况下我们还是希望自动释放，那就是在面对在一个方法作用域中要生成大量的 autorelease 对象的时候。在 Swift 1.0 时，我们可以写这样的代码：


```swift
 func loadBigData() {
      if let path = NSBundle.mainBundle()
          .pathForResource("big", ofType: "jpg") {

          for i in 1...10000 {
              let data = NSData.dataWithContentsOfFile(
                  path, options: nil, error: nil)

              NSThread.sleepForTimeInterval(0.5)
          }
      }
  }
```

8. dataWithContentsOfFile 返回的是 autorelease 的对象，因为我们一直处在循环中，因此它们将一直没有机会被释放。如果数量太多而且数据太大的时候，很容易因为内存不足而崩溃。在 Instruments 下可以看到内存 alloc 的情况：

9. 这显然是一幅很不妙的情景。在面对这种情况的时候，正确的处理方法是在其中加入一个自动释放池，这样我们就可以在循环进行到某个特定的时候施放内存，保证不会因为内存不足而导致应用崩溃。在 Swift 中我们也是能使用 autoreleasepool 的 -- 虽然语法上略有不同。相比于原来在 Objective-C 中的关键字，现在它变成了一个接受闭包的方法：

10. 利用尾随闭包的写法，很容易就能在 Swift 中加入一个类似的自动释放池了：


```Swift
func loadBigData() {
    if let path = NSBundle.mainBundle()
        .pathForResource("big", ofType: "jpg") {

        for i in 1...10000 {
            autoreleasepool {
                let data = NSData.dataWithContentsOfFile(
                    path, options: nil, error: nil)

                NSThread.sleepForTimeInterval(0.5)
            }
        }
    }
}

```

11. 这里我们每一次循环都生成了一个自动释放池，虽然可以保证内存使用达到最小，但是释放过于频繁也会带来潜在的性能忧虑。一个折衷的方法是将循环分隔开加入自动释放池，比如每 10 次循环对应一次自动释放，这样能减少带来的性能损失。
12. 其实对于这个特定的例子，我们并不一定需要加入自动释放。在 Swift 中更提倡的是用初始化方法而不是用像上面那样的类方法来生成对象，而且从 Swift 1.1 开始，因为加入了可以返回 nil 的初始化方法，像上面例子中那样的工厂方法都已经从 API 中删除了。今后我们都应该这样写：

> let data = NSData(contentsOfFile: path)

### 值类型和引用类型

1. Swift 的类型分为值类型和引用类型两种，值类型在传递和赋值时将进行复制，而引用类型则只会使用引用对象的一个 "指向"。Swift 中的 struct 和 enum 定义的类型是值类型，使用 class 定义的为引用类型。很有意思的是，Swift 中的所有的内建类型都是值类型，不仅包括了传统意义像 Int，Bool 这些，甚至连 String，Array 以及 Dictionary 都是值类型的。这在程序设计上绝对算得上一个震撼的改动，因为据我所知现在流行的编程语言中，像数组和字典这样的类型，几乎清一色都是引用类型。
2. 那么使用值类型有什么好处呢？相较于传统的引用类型来说，一个很显而易见的优势就是减少了堆上内存分配和回收的次数。首先我们需要知道，Swift 的值类型，特别是数组和字典这样的容器，在内存管理上经过了精心的设计。值类型的一个特点是在传递和赋值时进行复制，每次复制肯定会产生额外开销，但是在 Swift 中这个消耗被控制在了最小范围内，在没有必要复制的时候，值类型的复制都是不会发生的。也就是说，简单的赋值，参数的传递等等普通操作，虽然我们可能用不同的名字来回设置和传递值类型，但是在内存上它们都是同一块内容。比如下面这样的代码：


```Swift
func test(arr: [Int]) {
    for i in arr {
        print(i)
    }
}

var a = [1,2,3]
var b = a
let c = b
test(a)
```

3. 这么折腾一圈下来，其实我们只在第一句 a 初始化赋值时发生了内存分配，而之后的 b，c 甚至传递到 test 方法内的 arr，和最开始的 a 在物理内存上都是同一个东西。而且这个 a 还只在栈空间上，于是这个过程对于数组来说，只发生了指针移动，而完全没有堆内存的分配和释放的问题，这样的运行效率可以说极高。
4. 值类型被复制的时机是值类型的内容发生改变时，比如下面在 b 中又加入了一个数，此时值复制就是必须的了：


```Swift
var a = [1,2,3]
var b = a
b.append(5)
// 此时 a 和 b 的内存地址不再相同
```

5. 值类型在复制时，会将存储在其中的值类型一并进行复制，而对于其中的引用类型的话，则只复制一份引用。这是合理的行为，因为我们不会希望引用类型莫名其妙地引用到了我们设定以外其他对象：


```Swift
class MyObject {
    var num = 0
}

var myObject = MyObject()
var a = [myObject]
var b = a

b.append(myObject)

myObject.num = 100
print(b[0].num)   //100
print(b[1].num)   //100

// myObject 的改动同时影响了 b[0] 和 b[1]
```

6. 虽然将数组和字典设计为值类型最大的考虑是为了线程安全，但是这样的设计在存储的元素或条目数量较少时，给我们带来了另一个优点，那就是非常高效，因为 "一旦赋值就不太会变化" 这种使用情景在 Cocoa 框架中是占有绝大多数的，这有效减少了内存的分配和回收。
7. 但是在少数情况下，我们显然也可能会在数组或者字典中存储非常多的东西，并且还要对其中的内容进行添加或者删除。在这时，Swift 内建的值类型的容器类型在每次操作时都需要复制一遍，即使是存储的都是引用类型，在复制时我们还是需要存储大量的引用，这个开销就变得不容忽视了。幸好我们还有 Cocoa 中的引用类型的容器类来对应这种情况，那就是 NSMutableArray 和 NSMutableDictionary。
8. 所以，在使用数组合字典时的最佳实践应该是，按照具体的数据规模和操作特点来决定到时是使用值类型的容器还是引用类型的容器：在需要处理大量数据并且频繁操作 (增减) 其中元素时，选择 NSMutableArray 和 NSMutableDictionary 会更好，而对于容器内条目小而容器本身数目多的情况，应该使用 Swift 语言内建的 Array 和 Dictionary。

### STRING 还是 NSSTRING

1. 既然像 String 这样的 Swift 的类型和 Foundation 的对应的类是可以无缝转换的，那么我们在使用和选择的时候，有没有什么需要特别注意的呢？
2. 简单来说，没有特别需要注意的，但是尽可能的话还是使用原生的 String 类型。
3. 原因有三。
4. 首先虽然 String 和 NSString 有着良好的互相转换的特性，但是现在 Cocoa 所有的 API 都接受和返回 String 类型。我们没有必要也不必给自己凭空添加麻烦去把框架中返回的字符串做一遍转换，既然 Cocoa 鼓励使用 String，并且为我们提供了足够的操作 String 的方法，那为什么不直接使用呢？
5. 其次，因为在 Swift 中 String 是 struct，相比起 NSObject 的 NSString 类来说，更切合字符串的 "不变" 这一特性。通过配合常量赋值 (let) ，这种不变性在多线程编程时就非常重要了，它从原理上将程序员从内存访问和操作顺序的担忧中解放出来。另外，在不触及 NSString 特有操作和动态特性的时候，使用 String 的方法，在性能上也会有所提升。
6. 最后，因为 String 里的 String.CharacterView 实现了像 CollectionType 这样的接口，因此有些 Swift 的语法特性只有 String 才能使用，而 NSString 是没有的。一个典型就是 for...in 的枚举，我们可以写：


```Swift
let levels = "ABCDE"
for i in levels.characters {
    print(i)
}

// 输出：
// ABCDE

```

7. 而如果转换为 NSString 的话，是无法使用 characters 并且进行枚举的。
8. 不过也有例外的情况。有一些 NSString 的方法在 String 中并没有实现，一个很有用的就是在 iOS 8 中新加的 containsString。我们想使用这个 API 来简单地确定某个字符串包括一个子字符串时，只能先将其转为 NSString：


```Swift
if (levels as NSString).containsString("BC") {
    print("包含字符串")
}

// 输出：
// 包含字符串
```

> Swift 的 String 没有 containsString 是一件很奇怪的事情，理论上应该不存在实现的难度，希望只是 Apple 一时忘了这个新加的 API 吧。当然你也可以自行用扩展的方式在自己的代码库为 String 添加这个方法。当然，还有一些其他的像 length 和 characterAtIndex: 这样的 API 也没有 String 的版本，这主要是因为 String 和 NSString 在处理编码上的差异导致的。

9. 使用 String 唯一一个比较麻烦的地方在于它和 Range 的配合。在 NSString 中，我们在匹配字符串的时候通常使用 NSRange 来表征结果或者作为输入。而在使用 String 的对应的 API 时，NSRange 也会被映射成它在 Swift 中且对应 String 的特殊版本：Range<String.Index>。这有时候会让人非常讨厌：


```Swift
let levels = "ABCDE"

let nsRange = NSMakeRange(1, 4)
// 编译错误
// Cannot invoke `stringByReplacingCharactersInRange` 
// with an argument list of type '(NSRange, withString: String)'
levels.stringByReplacingCharactersInRange(nsRange, withString: "AAAA")

let indexPositionOne = levels.startIndex.successor()
let swiftRange = indexPositionOne ..< indexPositionOne.advancedBy(4)
levels.stringByReplacingCharactersInRange(swiftRange, withString: "AAAA")
// 输出：
// AAAAA
```

10. 一般来说，我们可能更愿意和基于 Int 的 NSRange 一起工作，而不喜欢使用麻烦的 Range<String.Index>。这种情况下，将 String 转为 NSString 也许是个不错的选择：

```Swift
let nsRange = NSMakeRange(1, 4)
(levels as NSString).stringByReplacingCharactersInRange(
    nsRange, withString: "AAAA")
```

### UNSAFEPOINTER

* Swift 本身从设计上来说是一门非常安全的语言，在 Swift 的思想中，所有的引用或者变量的类型都是确定并且正确对应它们的实际类型的，你应当无法进行任意的类型转换，也不能直接通过指针做出一些出格的事情。
* 这种安全性在日常的程序开发中对于避免不必要的 bug，以及迅速而且稳定地找出代码错误是非常有帮助的。但是凡事都有两面性，在高安全的同时，Swift 也相应地丧失了部分的灵活性。
* 现阶段想要完全抛弃 C 的一套东西还是相当困难的，特别是在很多上古级别的 C API 框架还在使用 (或者被间接使用)。开发者，尤其是偏向较底层的框架的开发者不得不面临着与 C API 打交道的时候，还是无法绕开指针的概念，而指针在 Swift 中其实并不被鼓励，语言标准中也是完全没有与指针完全等同的概念的。为了与庞大的 C 系帝国进行合作，Swift 定义了一套对 C 语言指针的访问和转换方法，那就是 UnsafePointer 和它的一系列变体。
* 对于使用 C API 时如果遇到接受内存地址作为参数，或者返回是内存地址的情况，在 Swift 里会将它们转为 UnsafePointer<Type> 的类型，比如说如果某个 API 在 C 中是这样的话：


```Swift
void method(const int *num) {
    printf("%d",*num);
}
```

* 其对应的 Swift 方法应该是：

```Swift
func method(num: UnsafePointer<CInt>) {
    print(num.memory)
}
```

* 我们这个 tip 所说的 UnsafePointer，就是 Swift 中专门针对指针的转换。对于其他的 C 中基础类型，在 Swift 中对应的类型都遵循统一的命名规则：在前面加上一个字母 C 并将原来的第一个字母大写：比如 int，bool 和 char 的对应类型分别是 CInt，CBool 和 CChar。在上面的 C 方法中，我们接受一个 int 的指针，转换到 Swift 里所对应的就是一个 CInt 的 UnsafePointer 类型。这里原来的 C API 中已经指明了输入的 num 指针的不可变的 (const)，因此在 Swift 中我们与之对应的是 UnsafePointer 这个不可变版本。如果只是一个普通的可变指针的话，我们可以使用 UnsafeMutablePointer 来对应：
* 在 C 中，对某个指针进行取值使用的是 *，而在 Swift 中我们可以使用 memory 属性来读取相应内存中存储的内容。通过传入指针地址进行方法调用的时候就都比较相似了，都是在前面加上 & 符号，C 的版本和 Swift 的版本只在声明变量的时候有所区别：


```Swift
// C
int a = 123;
method(&a);   // 输出 123

// Swift
var a: CInt = 123
method(&a)    // 输出 123
```

*  遵守这些原则，使用 UnsafePointer 在 Swift 中进行 C API 的调用应该就不会有很大问题了。
*  另外一个重要的课题是如何在指针的内容和实际的值之间进行转换。比如我们如果由于某种原因需要涉及到直接使用 CFArray 的方法来获取数组中元素的时候，我们会用到这个方法：

> func CFArrayGetValueAtIndex(theArray: CFArray!, idx: CFIndex)
                                            -> UnsafePointer<Void>
                                            
* 因为 CFArray 中是可以存放任意对象的，所以这里的返回是一个任意对象的指针，相当于 C 中的 void *。这显然不是我们想要的东西。Swift 中为我们提供了一个强制转换的方法 unsafeBitCast，通过下面的代码，我们可以看到应当如何使用类似这样的 API，将一个指针强制按位转成所需类型的对象：

```Swift
let arr = NSArray(object: "meow")
let str = unsafeBitCast(CFArrayGetValueAtIndex(arr, 0), CFString.self)
// str = "meow"
```

* unsafeBitCast 会将第一个参数的内容按照第二个参数的类型进行转换，而不去关心实际是不是可行，这也正是 UnsafePointer 的不安全所在，因为我们不必遵守类型转换的检查，而拥有了在指针层面直接操作内存的机会。
* 其实说了这么多，Apple 将直接的指针访问冠以 Unsafe 的前缀，就是提醒我们：这些东西不安全，亲们能不用就别用了吧 (作为 Apple，另一个重要的考虑是如果避免指针的话可以减少很多系统漏洞)！在日常开发中，我们确实不太需要经常和这些东西打交道 (除了传入 NSError 指针这个历史遗留问题以外，而且在 Swift 2.0 中也已经使用异常机制替代了 NSError)。总之，尽可能地在高抽象层级编写代码，会是高效和正确的有力保证。无数先辈已经用血淋淋的教训告诉我们，要避免去做这样的不安全的操作，除非你确实知道你在做的是什么。

### C 指针内存管理

1. C 指针在 Swift 中被冠名以 unsafe 的另一个原因是无法对其进行自动的内存管理。和 Unsafe 类的指针工作的时候，我们需要像 ARC 时代之前那样手动地来申请和释放内存，以保证程序不会出现泄露或是因为访问已释放内存而造成崩溃。
2. 我们如果想要声明，初始化，然后使用一个指针的话，完整的做法是使用 alloc 和 initialize 来创建。如果一不小心，就很容易写成下面这样：


```Swift
这是错误代码

class MyClass {
    var a = 1
    deinit {
        print("deinit")
    }
}

var pointer: UnsafeMutablePointer<MyClass>!

pointer = UnsafeMutablePointer<MyClass>.alloc(1)
pointer.initialize(MyClass())

print(pointer.memory.a)  // 1

pointer = nil
```

3. 虽然我们最后将 pointer 值为 nil，但是由于 UnsafeMutablePointer 并不会自动进行内存管理，因此其实 pointer 所指向的内存是没有被释放和回收的 (这可以从 MyClass 的 deinit 没有被调用来加以证实；这造成了内存泄露。正确的做法是为 pointer 加入 destroy 和 dealloc，它们分别会释放指针指向的内存的对象以及指针自己本身


```swift
var pointer: UnsafeMutablePointer<MyClass>!

pointer = UnsafeMutablePointer<MyClass>.alloc(1)
pointer.initialize(MyClass())

print(pointer.memory.a)
pointer.destroy()
pointer.dealloc(1)
pointer = nil

// 输出：
// 1
// deinit
```

4. 如果我们在 dealloc 之后再去访问 pointer 或者再次调用 dealloc 的话，迎接我们的自然是崩溃。这并不出意料之外，相信有过手动管理经验的读者都会对这种场景非常熟悉了。
5. 在手动处理这类指针的内存管理时，我们需要遵循的一个基本原则就是谁创建谁释放。destroy 与 dealloc 应该要与 alloc 成对出现，如果不是你创建的指针，那么一般来说你就不需要去释放它。一种最常见的例子就是如果我们是通过调用了某个方法得到的指针，那么除非文档或者负责这个方法的开发者明确告诉你应该由使用者进行释放，否则都不应该去试图管理它的内存状态：


```swift
var x:UnsafeMutablePointer<tm>!
var t = time_t()
time(&t)
x = localtime(&t)
x = nil
```

6. 最后，虽然在本节的例子中使用的都是 alloc 和 dealloc 的情况，但是指针的内存申请也可以使用 malloc 或者 calloc 来完成，这种情况下在释放时我们需要对应使用 free 而不是 dealloc。

### COPAQUEPOINTER 和 C CONVENTION

1. 在 C 中有一类指针，你在头文件中无法找到具体的定义，只能拿到类型的名字，而所有的实现细节都是隐藏的。这类指针在 C 或 C++ 中被叫做不透明指针 (Opaque Pointer)，顾名思义，它的实现和表意对使用者来说是不透明的。
2. 我们在这里不想过多讨论 C 中不透明指针的应用场景和特性，毕竟这是一本关于 Swift 的书。在 Swift 中对应这类不透明指针的类型是 COpaquePointer，它用来表示那些在 Swift 中无法进行类型描述的 C 指针。那些能够确定类型的指针所表示的是其指向的内存是可以用某个 Swift 中的类型来描述的，因此都使用更准确的 UnsafePointer<T> 来存储。而对于另外那些 Swift 无法表述的指针，就统一写为 COpaquePointer，以作补充。
3. 在 Swift 早期 beta 的时候，曾经有不少 API 返回或者接受的是 COpaquePointer 类型。但是随着 Swift 的逐渐完善，大部分涉及到指针的 API 里的 COpaquePointer 都被正确地归类到了合适的 Unsafe 指针中，因此现在在开发中可能很少能再看到 COpaquePointer 了。最多的使用场景可能就是 COpaquePointer 和某个特定的 Unsafe 之间的转换了，我们可以分别使用这两个类型的初始化方法将一个指针转换从某个类型强制地转为另一个类型：


```swift
public struct UnsafeMutablePointer<Memory> :
                        Equatable, Hashable ... {

    //..

    init(_ other: COpaquePointer)

    //..
}

public struct COpaquePointer:
                Equatable,
                Hashable,
                NilLiteralConvertible {
    //..

    init<T>(_ source: UnsafePointer<T>)

    //..
}
```

4. COpaquePointer 在 Swift 中扮演的是指针转换的中间人的角色，我们可以通过这个类型在不同指针类型减进行转换。当然了，这些转换都是不安全的，除非你知道自己在干什么，以及有十足的把握，否则不要这么做！
5. 另外一种重要的指针形式是指向函数的指针，在 C 中这种情况也并不少见，即一块存储了某个函数实际所在的位置的内存空间。从 Swift 2.0 开始，与这类指针可以被转化为闭包，不过和其他普通闭包不同，我们需要为它添加上 @convention 标注。
6. 举个例子，如果我们在 C 中有这样一个函数：


```swift
int cFunction(int (callback)(int x, int y)) {
    return callback(1, 2);
}
```

7. 这个函数接受一个 callback，这个 callback 有两个 int 类型的参数，cFunction 本身返回这个 callback 的结果。如果我们想在 Swift 中使用这个 C 函数的话，应该这样写：


```swift
let callback: @convention(c) (Int32, Int32) -> Int32 = {
    (x, y) -> Int32 in
    return x + y
}

let result = cFunction(callback)
print(result)
// 输出：
// 3
```

8. 在没有歧义的情况下，我们甚至可以省掉这个标注，而直接将它以一个 Swift 闭包的形式传递给 C：

```swift
let result = cFunction {
    (x, y) -> Int32 in
    return x + y
}
print(result)
// 输出：
// 3
```
### GCD 和延时调用

1. 因为 Playground 不进行特别配置的话是无法在线程中进行调度的，因此本节中的示例代码需要在 Xcode 项目环境中运行。在 Playground 中可能无法得到正确的结果。
2. GCD 是一种非常方便的使用多线程的方式。通过使用 GCD，我们可以在确保尽量简单的语法的前提下进行灵活的多线程编程。在 “复杂必死” 的多线程编程中，保持简单就是避免错误的金科玉律。好消息是在 Swift 中是可以无缝使用 GCD 的 API 的，而且得益于闭包特性的加入，使用起来比之前在 Objective-C 中更加简单方便。
3. 在这里我不打算花费很多时间介绍 GCD 的语法和要素，如果这么做的话就可以专门为 GCD 写上一节了。在下面我给出了一个日常里最通常会使用到的例子 (说这个例子能覆盖到日常的 GCD 使用的 50% 以上也不为过)，来展示一下 Swift 里的 GCD 调用会是什么样子：


```Swift
// 创建目标队列
let workingQueue = dispatch_queue_create("my_queue", nil)

// 派发到刚创建的队列中，GCD 会负责进行线程调度
dispatch_async(workingQueue) {
    // 在 workingQueue 中异步进行
    print("努力工作")
    NSThread.sleepForTimeInterval(2)  // 模拟两秒的执行时间

    dispatch_async(dispatch_get_main_queue()) {
        // 返回到主线程更新 UI
        print("结束工作，更新 UI")
    }
}
```

4. 因为 UIKit 是只能在主线程工作的，如果我们在主线程进行繁重的工作的话，就会导致 app 出现 “卡死” 的现象：UI 不能更新，用户输入无法响应等等，是非常糟糕的用户体验。为了避免这种情况的出现，对于繁重 (如图像加滤镜等) 或会很长时间才能完成的 (如从网络下载图片) 处理，我们应该把它们放到后台线程进行，这样在用户看来 UI 还是可以交互的，也不会出现卡顿。在工作进行完成后，我们需要更新 UI 的话，必须回到主线程进行 (牢记 UI 相关的工作都需要在主线程执行，否则可能发生不可预知的错误)。
5. 在日常的开发工作中，我们经常会遇到这样的需求：在 xx 秒后执行某个方法。比如切换界面 2 秒后开始播一段动画，或者提示框出现 3 秒后自动消失等等。以前在 Objective-C 中，我们可以使用一个 NSObject 的实例方法，-performSelector:withObject:afterDelay: 来指定在若干时间后执行某个 selector。在 Swift 2 之前，如果你新建一个 Swift 的项目，并且试图使用这个方法 (或者这个方法的其他一切变形) 的话，会发现这个方法并不存在。在 Swift 2 中虽然这一系列 performSelector 的方法被加回了标准库，但是由于 Swift 中创建一个 selector 并不是一件安全的事情 (你需要通过字符串来创建，这在之后代码改动时会很危险)，所以最好尽可能的话避免使用这个方法。另外，原来的 performSelector: 这套东西在 ARC 下并不是安全的。ARC 为了确保参数在方法运行期间的存在，在无法准确确定参数内存情况的时候，会将输入参数在方法开始时先进行 retain，然后在最后 release。而对于 performSelector: 这个方法我们并没有机会为被调用的方法指定参数，于是被调用的 selector 的输入有可能会是指向未知的垃圾内存地址，然后...HOHO，要命的是这种崩溃还不能每次重现，想调试？见鬼去吧..
6. 但是如果不论如何，我们都还想继续做延时调用的话应该怎么办呢？最容易想到的是使用 NSTimer 来创建一个若干秒后调用一次的计时器。但是这么做我们需要创建新的对象，和一个本来并不相干的 NSTimer 类扯上关系，同时也会用到 Objective-C 的运行时特性去查找方法等等，总觉着有点笨重。其实 GCD 里有一个很好用的延时调用我们可以加以利用写出很漂亮的方法来，那就是 dispatch_after。最简单的使用方法看起来是这样的：


```Swift
let time: NSTimeInterval = 2.0
let delay = dispatch_time(DISPATCH_TIME_NOW,
                         Int64(time * Double(NSEC_PER_SEC)))
dispatch_after(delay, dispatch_get_main_queue()) {
    print("2 秒后输出")
}
```

7. 代码非常简单，并没什么值得详细说明的。只是每次写这么多的话也挺累的，在这里我们可以稍微将它封装的好用一些，最好再加上取消的功能。在 iOS 8 中 GCD 得到了惊人的进化，现在我们可以通过将一个 dispatch_block_t 对象传递给 dispatch_block_cancel，来取消一个正在等待执行的 block。取消一个任务这样的特性，这在以前是 NSOperation 的专利，但是现在我们使用 GCD 也能达到同样的目的了。这里我们将类似地来尝试实现 delay call 的取消，整个封装也许有点长，但我还是推荐一读。大家也可以把它当作练习材料检验一下自己的 Swift 基础语法的掌握和理解的情况：



```swift
import Foundation

typealias Task = (cancel : Bool) -> Void

func delay(time:NSTimeInterval, task:()->()) ->  Task? {

    func dispatch_later(block:()->()) {
        dispatch_after(
            dispatch_time(
                DISPATCH_TIME_NOW,
                Int64(time * Double(NSEC_PER_SEC))),
            dispatch_get_main_queue(),
            block)
    }

    var closure: dispatch_block_t? = task
    var result: Task?

    let delayedClosure: Task = {
        cancel in
        if let internalClosure = closure {
            if (cancel == false) {
                dispatch_async(dispatch_get_main_queue(), internalClosure);
            }
        }
        closure = nil
        result = nil
    }

    result = delayedClosure

    dispatch_later {
        if let delayedClosure = result {
            delayedClosure(cancel: false)
        }
    }

    return result;
}

func cancel(task:Task?) {
    task?(cancel: true)
}
```

8. 使用的时候就很简单了，我们想在 2 秒以后干点儿什么的话：

> delay(2) { print("2 秒后输出") }
9. 想要取消的话，我们可以先保留一个对 Task 的引用，然后调用 cancel：

```swift
let task = delay(5) { print("拨打 110") }

// 仔细想一想..
// 还是取消为妙..
cancel(task)
```
### 获取对象类型


1. 我们一再强调，如果遵循规则的话，Swift 会是一门相当安全的语言：不会存在类型的疑惑，绝大多数的内容应该能在编译期间就唯一确定。
2. 但是不论是 Objective-C 里很多开发者早已习惯的灵活性，还是在程序世界里总是千变万化的需求，都不可能保证一成不变。我们有时候也需要引入一定的动态特性。而其中最为基本但却是最为有用的技巧是获取任意一个实例类型。
3. 在 Objective-C 中我们可以轻而易举地做到这件事，使用 -class 方法就可以拿到对象的类，我们甚至可以用 NSStringFromClass 将它转换为一个能够打印出来的字符串：


```Swift
NSDate *date = [NSDate date];
NSLog(@"%@",NSStringFromClass([date class]));
// 输出：
// __NSDate
```

4. 在 Swift 中，我们会发现不管是纯 Swift 的 class 还是 NSObject 的子类，都没有像原来那样的 class() 方法来获取类型了。对于 NSObject 的子类，因为其实类的信息的存储方式并没有发生什么大的变化，因此我们可以求助于 Objective-C 的运行时，来获取类并按照原来的方式转换：


```Swift
let date = NSDate()
let name: AnyClass! = object_getClass(date)
print(name)
// 输出：
// __NSDate

```

5. 其中 object_getClass 是一个定义在 ObjectiveC 的 runtime 中的方法，它可以接受任意的 AnyObject! 并返回它的类型 AnyClass! (注意这里的叹号，它表明我们甚至可以输入 nil，并期待其返回一个 nil)。在 Swift 中其实为了获取一个 NSObject 或其子类的对象的实际类型，对这个调用其实有一个好看一些的写法，那就是 dynamicType。上面的代码用一种 "更 Swift" 一些的语言转换一下，会是这个样子：


```swift
let date = NSDate()
let name = date.dynamicType
print(name)
// 输出：
// __NSDate
```

6. 很好，似乎我们的问题能解决了。但是仔细想想，我们上面用的都是 Objective-C 的动态特性，要是换成一个 Swift 内建类型的话，会怎么样呢？比如原生的 String，


```swift
let string = "Hello"
let name = string.dynamicType
print(name)
// 输出：
// String
```

7. 可以看到对于 Swift 的原生类型，这种方式也是可行的。(值得指出的是，其实这里的真正的类型名字还带有 module 前缀，也就是 Swift.String。直接 print 只是调用了 CustomStringConvertible 中的相关方法而已，你可以使用 debugPrint 来进行确认。关于更多地关于 print 和 debugPrint 的细节，可以参考 print 和 debugPrint 一节的内容。

### 自省

1. 程序设计和人类哲学所面临的同一个很重大的课题就是解决 "我是谁" 这个问题。在哲学里，这个问题属于自我认知的范畴，而在程序设计时，这个问题涉及到自省 (Introspection)。
2. 向一个对象发出询问，以确定它是不是属于某个类，这种操作就称为自省。在 Objective-C 中因为 id 这样的可以指向任意对象的指针的存在 (其实严格来说 Objective-C 的指针的类型都是可以任意指向和转换的，它们只不过是帮助编译器理解你的代码而已)，我们经常需要向一个对象询问它是不是属于某个类。常用的方法有下面两类：


```swift
[obj1 isKindOfClass:[ClassA class]];
[obj2 isMemberOfClass:[ClassB class]];
```

3. -isKindOfClass: 判断 obj1 是否是 ClassA 或者其子类的实例对象；而 isMemberOfClass: 则对 obj2 做出判断，当且仅当 obj2 的类型为 ClassB 时返回为真。
4. 这两个方法是 NSObject 的方法，所以我们在 Swift 中如果写的是 NSObject 的子类的话，直接使用这两个方法是没有任何问题的：


```swift
class ClassA: NSObject { }
class ClassB: ClassA { }

let obj1: NSObject = ClassB()
let obj2: NSObject = ClassB()

obj1.isKindOfClass(ClassA.self)    // true
obj2.isMemberOfClass(ClassA.self)  // false
```

5. 关于 .self 的用法，我们在 .self 和 AnyClass 一节里已经有所提及，这里就不再重复了。
6. 在 Objective-C 中我们几乎所有的类都会是 NSObject 的子类，而在 Swift 的世界中，处于性能考虑，只要有可能，我们应该更倾向于选择那些非 NSObject 子类的 Swift 原生类型。对于那些不是 NSObject 的类，我们应该怎么确定其类型呢？
7. 首先需要明确的一点是，我们为什么需要在运行时去确定类型。因为有泛型支持，Swift 对类型的推断和记录是完备的。因此在绝大多数情况下，我们使用的 Swift 类型都应该是在编译期间就确定的。如果在你写的代码中经常需要检查和确定 AnyObject 到底是什么类的话，几乎就意味着你的代码设计出了问题 (或者你正在写一些充满各种 "小技巧" 的代码)。虽然没有太多的意义，但是我们还是可以做这件事情：


```swift
class ClassA { }
class ClassB: ClassA { }

let obj1: AnyObject = ClassB()
let obj2: AnyObject = ClassB()

obj1.isKindOfClass(ClassA.self)    // true
obj2.isMemberOfClass(ClassA.self)  // false
```

8. 在 Swift 中对于 AnyObject 使用最多的地方应该就是原来那些返回 id 的 Cocoa API 了。
9. 为了快速确定类型，Swift 提供了一个简洁的写法：对于一个不确定的类型，我们现在可以使用 is 来进行判断。is 在功能上相当于原来的 isKindOfClass，可以检查一个对象是否属于某类型或其子类型。is 和原来的区别主要在于亮点，首先它不仅可以用于 class 类型上，也可以对 Swift 的其他像是 struct 或 enum 类型进行判断。使用起来是这个样子的：


```swift
class ClassA { }
class ClassB: ClassA { }

let obj: AnyObject = ClassB()

if (obj is ClassA) {
    print("属于 ClassA")
}

if (obj is ClassB) {
    print("属于 ClassB")
}
```

10. 另外，编译器将对这种检查进行必要性的判断：如果编译器能够唯一确定类型，那么 is 的判断就没有必要，编译器将会抛出一个警告，来提示你并没有转换的必要。


```swift
let string = "String"
if string is String {
    // Do something
}

// 'is' test is always true
```

### KVO

1. KVO (Key-Value Observing) 是 Cocoa 中公认的最强大的特性之一，但是同时它也以烂到家的 API 和极其难用著称。和属性观察不同，KVO 的目的并不是为当前类的属性提供一个钩子方法，而是为了其他不同实例对当前的某个属性 (严格来说是 keypath) 进行监听时使用的。其他实例可以充当一个订阅者的角色，当被监听的属性发生变化时，订阅者将得到通知。
2. 这是一个很强大的属性，通过 KVO 我们可以实现很多松耦合的结构，使代码更加灵活和强大：像通过监听 model 的值来自动更新 UI 的绑定这样的工作，基本都是基于 KVO 来完成的。
3. 在 Swift 中我们也是可以使用 KVO 的，但是仅限于在 NSObject 的子类中。这是可以理解的，因为 KVO 是基于 KVC (Key-Value Coding) 以及动态派发技术实现的，而这些东西都是 Objective-C 运行时的概念。另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 dynamic。
4. 在 Swift 中，为一个 NSObject 的子类实现 KVO 的最简单的例子看起来是这样的：


```Swift
class MyClass: NSObject {
    dynamic var date = NSDate()
}

private var myContext = 0

class Class: NSObject {

    var myObject: MyClass!

    override init() {
        super.init()
        myObject = MyClass()
        print("初始化 MyClass，当前日期: \(myObject.date)")
        myObject.addObserver(self,
            forKeyPath: "date",
            options: .New,
            context: &myContext)

        delay(3) {
            self.myObject.date = NSDate()
        }
    }

    override func observeValueForKeyPath(keyPath: String?,
            ofObject object: AnyObject?,
            change: [String : AnyObject]?,
            context: UnsafeMutablePointer<Void>)
    {
        if let change = change where context == &myContext {
            let a = change[NSKeyValueChangeNewKey]
            print("日期发生变化 \(a)")
        }
    }
}

let obj = Class()
```

> 这段代码中用到了一个叫做 delay 的方法，这不是 Swift 的方法，而是本书在延时调用一节中实现的一个方法。这里您只需要理解我们是过了三秒以后在主线程将 myObject 中的时间更新到了当前时间即可。


6.  我们标明了 MyClass 的 date 为 dynamic，然后在一个 Class 的 init 中将自己添加为该实例的观察者。接下来等待了三秒钟之后改变了这个对象的被观察属性，这时我们的观察方法就将被调用。运行这段代码，输出应该类似于：


```Swift
初始化 MyClass，当前日期: 2014-08-23 16:37:20 +0000
日期发生变化 Optional(2014-08-23 16:37:23 +0000)
```

7. 别忘了，新的值是从字典中取出的。虽然我们能够确定 (其实是 Cocoa 向我们保证) 这个字典中会有相应的键值，但是在实际使用的时候我们最好还是进行一下判断或者 Optional Binding 后再加以使用，毕竟世事难料。
8. 在 Swift 中使用 KVO 有两个显而易见的问题。
9. 首先是 Swift 的 KVO 需要依赖的东西比原来多。在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，而现在我们需要属性有 dynamic 进行修饰。大多数情况下，我们想要观察的类不一定是 dynamic 修饰的 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上 dynamic，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，一个可能可行的方案是继承这个类并且将需要观察的属性使用 dynamic 进行重写。比如刚才我们的 MyClass 中如果 date 没有 dynamic 的话，我们可能就需要一个新的 MyChildClass 了：


```Swift
class MyClass: NSObject {
    var date = NSDate()
}

class MyChildClass: MyClass {
    dynamic override var date: NSDate {
        get { return super.date }
        set { super.date = newValue }
    }
}
```

10. 对于这种重载，我们没有必要改变什么逻辑，所以在子类中简单地用 super 去调用父类里相关的属性就可以了。
11. 另一个大问题是对于那些非 NSObject 的 Swift 类型怎么办。因为 Swift 类型并没有通过 KVC 进行实现，所以更不用谈什么对属性进行 KVO 了。对于 Swift 类型，语言中现在暂时还没有原生的类似 KVO 的观察机制。我们可能只能通过属性观察来实现一套自己的类似替代了。结合泛型和闭包这些 Swift 的先进特性 (当然是相对于 Objective-C 来说的先进特性)，把 API 做得比原来的 KVO 更优雅其实不是一件难事。Observable-Swift 就利用了这个思路实现了一套对 Swift 类型进行观察的机制，如果您也有类似的需求，不妨可以参考看看。

### 局部 SCOPE

* C 系语言中在方法内部我们是可以任意添加成对的大括号 {} 来限定代码的作用范围的。这么做一般来说有两个好处，首先是超过作用域后里面的临时变量就将失效，这不仅可以使方法内的命名更加容易，也使得那些不被需要的引用的回收提前进行了，可以稍微提高一些代码的效率；另外，在合适的位置插入括号也利于方法的梳理，对于那些不太方便提取为一个单独方法，但是又应该和当前方法内的其他部分进行一些区分的代码，使用大括号可以将这样的结构进行一个相对自然的划分。
* 举一个不失一般性的例子，虽然我个人不太喜欢使用代码手写 UI，但钟情于这么做的人还是不在少数。如果我们要在 Objective-C 中用代码构建 UI 的话，我们一般会选择在 -loadView 里写一些类似这样的代码：


```Object-c
-(void)loadView {
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)];

    UILabel *titleLabel = [[UILabel alloc]
            initWithFrame:CGRectMake(150, 30, 20, 40)];
    titleLabel.textColor = [UIColor redColor];
    titleLabel.text = @"Title";
    [view addSubview:titleLabel];

    UILabel *textLabel = [[UILabel alloc]
            initWithFrame:CGRectMake(150, 80, 20, 40)];
    textLabel.textColor = [UIColor redColor];
    textLabel.text = @"Text";
    [view addSubview:textLabel];

    self.view = view;
}
```

* 在这里只添加了两个 view，就已经够让人心烦的了。真实的界面当然会比这个复杂很多，想想看如果有十来个 view 的话，这段代码会变成什么样子吧。我们需要考虑对各个子 view 的命名，以确保它们的意义明确。如果我们在上面的代码中把某个配置 textLabel 的代码写错成了 titleLabel 的话，编译器也不会给我们任何警告。这种 bug 是非常难以发现的，因此在类似这种一大堆代码但是又不太可能进行重用的时候，我更推荐使用局部 scope 将它们分隔开来。比如上面的代码建议加上括号重写为以下形式，这样至少编译器会提醒我们一些低级错误，我们也可能更专注于每个代码块：


```object-c
-(void)loadView {
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 320, 480)];

    {
        UILabel *titleLabel = [[UILabel alloc]
                initWithFrame:CGRectMake(150, 30, 20, 40)];
        titleLabel.textColor = [UIColor redColor];
        titleLabel.text = @"Title";
        [view addSubview:titleLabel];
    }

    {
        UILabel *textLabel = [[UILabel alloc]
                initWithFrame:CGRectMake(150, 80, 20, 40)];
        textLabel.textColor = [UIColor redColor];
        textLabel.text = @"Text";
        [view addSubview:textLabel];
    }

    self.view = view;
}
```

* 在 Swift 中，直接使用大括号的写法是不支持的，因为这和闭包的定义产生了冲突。如果我们想类似地使用局部 scope 来分隔代码的话，一个不错的选择是定义一个接受 ()->() 作为函数的全局方法，然后执行它：


```Swift
func local(closure: ()->()) {
    closure()
}

override func loadView() {
    let view = UIView(frame: CGRectMake(0, 0, 320, 480))

    local {
        let titleLabel = UILabel(frame: CGRectMake(150, 30, 20, 40))
        titleLabel.textColor = UIColor.redColor()
        titleLabel.text = "Title"
        view.addSubview(titleLabel)
    }

    local {
        let textLabel = UILabel(frame: CGRectMake(150, 80, 20, 40))
        textLabel.textColor = UIColor.redColor()
        textLabel.text = "Text"
        view.addSubview(textLabel)
    }

    self.view = view
}
```

* 不过在 Swift 2.0 中，为了处理异常，Apple 加入了 do 这个关键字来作为捕获异常的作用域。这一功能恰好为我们提供了一个完美的局部作用域，现在我们可以简单地使用 do 来分隔代码了


```Swift
do {
    let textLabel = UILabel(frame: CGRectMake(150, 80, 20, 40))
    //...
}
```

* 在 Objective-C 中还有一个很棒的技巧是使用 GNU C 的声明扩展来在限制局部作用域的时候同时进行赋值，运用得当的话，可以使代码更加紧凑和整洁。比如上面的 titleLabel 如果我们需要保留一个引用的话，在 Objective-C 中可以写为：


```Swift
self.titleLabel = ({
    UILabel *label = [[UILabel alloc]
            initWithFrame:CGRectMake(150, 30, 20, 40)];
    label.textColor = [UIColor redColor];
    label.text = @"Title";
    [view addSubview:label];
    label;
});
```


* Swift 里当然没有 GNU C 的扩展，但是使用匿名的闭包的话，写出类似的代码也不是难事：

```Swift
titleLabel = {
    let label = UILabel(frame: CGRectMake(150, 30, 20, 40))
    label.textColor = UIColor.redColor()
    label.text = "Title"
    self.view.addSubview(label)
    return label
}()
//这也是一种隔离代码的很好的方式。
```






































































    

 
































# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```


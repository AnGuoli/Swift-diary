# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```

- 如果想要研究for...in 这样的方法到底做了什么，就将其展开。

```swift
var g = arrar.generate()

while let obj = g.next(){
    print(obj)
}
```

- 顺便可以得到的收益可以使用map，filter和reduce这些方法，因为SequenceType接口扩展(protocol extension）已经实现他们

```swift
extension SequenceType {
    func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->[T]
    func filter(@noescape includeElement:(Self.Generator.Element) -> Bool) -> [Self.Generator.Element]
    func reduce<T>(inittial: T,@noescape combine: (T, Self.Generator.Element) - >T) -> T
}
```

### 多元组(Tuple)

- 交换输入

```swift

func swapMe<T>(inout a: T, inout b: T){
    let temp = a
    a = b
    b = temp
}

```

- 上述是普通的写法，一下就是使用多元组的话，我们可以不适用额外空间完成交换

```swift
func swapMe<T>(inout a: T, inout b: T){
    (a,b) = (b,a)
}
```

- 说明：
1. 在oc中有不少需要传递指针的地方，以前的错误处理NSError就是个很好的例子，不过在Swift2.0中，传入指针的NSError已经新加入的异常机制取代，所以举例说明

```
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)

CGRect rect = CGRectMake(0,0,100,100);
CGRect small;
CGRect large;
CGRectDivide(rect, &small, &large, 20, CGRectGetMinXEdge);
```

- 上诉代码不直观又很麻烦，我们用Swift采用多元组方式同时返回被分割的部分和剩余的部分

```swift
extension CGRect {
    func divide(atDistance: CGFloat, formEdge: CGRectEdge) ->(slice: CGRect,remainder: CGRect)
}
```

- 然后使用时，相比之前的做法，现在就非常简单了，而且非常容易理解

```swift
let rect = CGRectMake(0,0,100,100)
let (small,large) = rect.divide(20,fromEdge: .MinXEdge)
```

### @autoclosure和 ？？

- @autoclosure做的事情就是把一句表达式自动分封装成一个闭包(closure)

- 比如我们有一个方法接受一个闭包，当闭包执行的结果true的时候进行打印

```swift
func logIfTrue(predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```
- 在调用的时候，代码可以这样写

```swift
logIfTrue({return 2 > 1})
```
- 当然对闭包的用法可以进行一步简化

```swift
logIfTrue({2 > 1})
```
- 还可以更进一步，因为这个闭包是最后一个参数，所以可以用尾随闭包的方式把大括号拿出来，然后省略
```swift
logIfTrue{2 > 1}
```
-  @autoclosure来实现效果，在参数前面加上 @autoclosure关键字

```swift
func logIfTure(@autoclosure predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```

- 这时候我们可以直接使用下面的代码进行强调用,自动转换为() -> Bool 

```swift
logIfTure(2 > 1)
```

1. 在Swift中，有一个非常有用的操作符，可以用来快速对nil进行条件判断，那就是 ？？ 这个操作符可以判断输入内容，并在当左侧的值是非nil的optional值时返回其value，左侧是nil时返回右侧的值
2.比如

```swift
var level : Int?
var startLevel = 1

var currentLevel = level ?? startLevel
```
3. 说明

- 在这个例子中我们没有设置过level，因此最后startLeveal被赋值给currentLevel
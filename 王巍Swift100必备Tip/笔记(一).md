# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```

- 如果想要研究for...in 这样的方法到底做了什么，就将其展开。

```swift
var g = arrar.generate()

while let obj = g.next(){
    print(obj)
}
```

- 顺便可以得到的收益可以使用map，filter和reduce这些方法，因为SequenceType接口扩展(protocol extension）已经实现他们

```swift
extension SequenceType {
    func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->[T]
    func filter(@noescape includeElement:(Self.Generator.Element) -> Bool) -> [Self.Generator.Element]
    func reduce<T>(inittial: T,@noescape combine: (T, Self.Generator.Element) - >T) -> T
}
```

### 多元组(Tuple)

- 交换输入

```swift

func swapMe<T>(inout a: T, inout b: T){
    let temp = a
    a = b
    b = temp
}

```

- 上述是普通的写法，一下就是使用多元组的话，我们可以不适用额外空间完成交换

```swift
func swapMe<T>(inout a: T, inout b: T){
    (a,b) = (b,a)
}
```

- 说明：
1. 在oc中有不少需要传递指针的地方，以前的错误处理NSError就是个很好的例子，不过在Swift2.0中，传入指针的NSError已经新加入的异常机制取代，所以举例说明

```
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)

CGRect rect = CGRectMake(0,0,100,100);
CGRect small;
CGRect large;
CGRectDivide(rect, &small, &large, 20, CGRectGetMinXEdge);
```

- 上诉代码不直观又很麻烦，我们用Swift采用多元组方式同时返回被分割的部分和剩余的部分

```swift
extension CGRect {
    func divide(atDistance: CGFloat, formEdge: CGRectEdge) ->(slice: CGRect,remainder: CGRect)
}
```

- 然后使用时，相比之前的做法，现在就非常简单了，而且非常容易理解

```swift
let rect = CGRectMake(0,0,100,100)
let (small,large) = rect.divide(20,fromEdge: .MinXEdge)
```

### @autoclosure和 ？？

- @autoclosure做的事情就是把一句表达式自动分封装成一个闭包(closure)

- 比如我们有一个方法接受一个闭包，当闭包执行的结果true的时候进行打印

```swift
func logIfTrue(predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```
- 在调用的时候，代码可以这样写

```swift
logIfTrue({return 2 > 1})
```
- 当然对闭包的用法可以进行一步简化

```swift
logIfTrue({2 > 1})
```
- 还可以更进一步，因为这个闭包是最后一个参数，所以可以用尾随闭包的方式把大括号拿出来，然后省略
```swift
logIfTrue{2 > 1}
```
-  @autoclosure来实现效果，在参数前面加上 @autoclosure关键字

```swift
func logIfTure(@autoclosure predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```

- 这时候我们可以直接使用下面的代码进行强调用,自动转换为() -> Bool 

```swift
logIfTure(2 > 1)
```

1. 在Swift中，有一个非常有用的操作符，可以用来快速对nil进行条件判断，那就是 ？？ 这个操作符可以判断输入内容，并在当左侧的值是非nil的optional值时返回其value，左侧是nil时返回右侧的值
2.比如

```swift
var level : Int?
var startLevel = 1

var currentLevel = level ?? startLevel
```
3. 说明

- 在这个例子中我们没有设置过level，因此最后startLeveal被赋值给currentLevel。我们看看 ？？的定义

```swift
func ??<T>(optional: T?,@autoclosure defaultValue: () -> T?) -> T?

func ??<T>(optional: T?,@autoclosure defaultValue: () -> T) -> T
```
- 在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int，但其实在使用时它被自动封装成一个() -> Intt 有了这个提示，测试一下

```swift
func ??<T>(optional: T?, @autoclosure defauleValue: () -> T) -> T {
    switch optional {
    case .Some(let value):
        return value
    case .None:
        return defauleValue()
    }
}
```

- 1. 为什么这里要使用autoclosure，直接接受T作为参数并返回不行吗？这正是autoclosure的一个最值得称赞的地方。假设使用T，那么意味着？？操作符真正取值之前，我们必须准备好一个默认值，这个默认值的准备和计算会降低性
- 2. 我们可以巧妙绕过条件判断和强制转换，以很优雅的写法处理对optional默认值取值了。

### Optional Chaining


------------

- 使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要谨慎，因为Optional Chaining是随时都可能提前返回nil，所以使用Optional Chaining所得到的东西其实都是optional

```swift
class Toy {
    let name: String
    init(name: String){
        self.name = name
    }
    
}

class Pet {
    var toy: Toy?
}

class child {
    var pet: Pet?
}

```

- 在实际使用中，我们想知道小明的宠物的玩具名字的时候，可以通过以下的**Optional Chaining**得到

```swift
let toyName = xiaoming.pet?.toy?.name
```

1. 注意我们最后访问的是name，并且在Toy的定义中name是被定义一个确定的String而非String？但是我们得到的toyName其实还是一个Strin类型，这是由于在Optional Chaining中，我们任意一个 ？.的时候可能遇到nil提前返回，这个时候只能得到nil
2. 在实际使用中，我们在大多数情况下可能更希望使用Optional Chaining来直接取值的代码

```swift
if let toyName = xiaoming.pet?.toy?.name {
    //太好了，小明有宠物，而且宠物还是正好有个玩具
}
```

3. 可能单独拿出来会很清楚，不过稍微结合一下其他特征就会变得很复杂起来

```swift
extension Toy {
    func play(){
    
    }
}
```

4. 我们为Toy定义一个扩展，以及一个玩玩具的play()方法，还是举例小明有玩具玩

```swift
xiaoming.pet?.toy?.play()
```
- 除了小明，还有有很多人等，这时候我们会想要把这一串抽象出来，做一个闭包以方便使用，传入一个child对象，日过小朋友有宠物并且宠物有玩具的话，就去玩

```swift
//无意义代码
let playClosure = {(child: child) -> () in child.pet?.toy?.play()}
```

- **问题在哪里？**

1. play()调用上，定义的时候没有卸载play()的返回，这表示这个方法返回Void。但是经过Optional Chaining得到的optional的结果，也就是说，我们最后得到应该是这样一个closure

```swift
//
let playClosure = {(child: child) -> ()? in child.pet?.toy?.play()}
```

- 这样调用的返回是一个()?，使用的时候我可以通过Optional Chaining来判定方法是否调用成功

```swift
if let result: () = playClosure(xiaoming) {
    print("好开心")
}else{
    print("没有玩具可玩 :(")
}
```
### 操作符
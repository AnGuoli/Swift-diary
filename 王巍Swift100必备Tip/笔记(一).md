# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```

- 如果想要研究for...in 这样的方法到底做了什么，就将其展开。

```swift
var g = arrar.generate()

while let obj = g.next(){
    print(obj)
}
```

- 顺便可以得到的收益可以使用map，filter和reduce这些方法，因为SequenceType接口扩展(protocol extension）已经实现他们

```swift
extension SequenceType {
    func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->[T]
    func filter(@noescape includeElement:(Self.Generator.Element) -> Bool) -> [Self.Generator.Element]
    func reduce<T>(inittial: T,@noescape combine: (T, Self.Generator.Element) - >T) -> T
}
```

### 多元组(Tuple)

- 交换输入

```swift

func swapMe<T>(inout a: T, inout b: T){
    let temp = a
    a = b
    b = temp
}

```

- 上述是普通的写法，一下就是使用多元组的话，我们可以不适用额外空间完成交换

```swift
func swapMe<T>(inout a: T, inout b: T){
    (a,b) = (b,a)
}
```

- 说明：
1. 在oc中有不少需要传递指针的地方，以前的错误处理NSError就是个很好的例子，不过在Swift2.0中，传入指针的NSError已经新加入的异常机制取代，所以举例说明

```
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)

CGRect rect = CGRectMake(0,0,100,100);
CGRect small;
CGRect large;
CGRectDivide(rect, &small, &large, 20, CGRectGetMinXEdge);
```

- 上诉代码不直观又很麻烦，我们用Swift采用多元组方式同时返回被分割的部分和剩余的部分

```swift
extension CGRect {
    func divide(atDistance: CGFloat, formEdge: CGRectEdge) ->(slice: CGRect,remainder: CGRect)
}
```

- 然后使用时，相比之前的做法，现在就非常简单了，而且非常容易理解

```swift
let rect = CGRectMake(0,0,100,100)
let (small,large) = rect.divide(20,fromEdge: .MinXEdge)
```

### @autoclosure和 ？？

- @autoclosure做的事情就是把一句表达式自动分封装成一个闭包(closure)

- 比如我们有一个方法接受一个闭包，当闭包执行的结果true的时候进行打印

```swift
func logIfTrue(predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```
- 在调用的时候，代码可以这样写

```swift
logIfTrue({return 2 > 1})
```
- 当然对闭包的用法可以进行一步简化

```swift
logIfTrue({2 > 1})
```
- 还可以更进一步，因为这个闭包是最后一个参数，所以可以用尾随闭包的方式把大括号拿出来，然后省略
```swift
logIfTrue{2 > 1}
```
-  @autoclosure来实现效果，在参数前面加上 @autoclosure关键字

```swift
func logIfTure(@autoclosure predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```

- 这时候我们可以直接使用下面的代码进行强调用,自动转换为() -> Bool 

```swift
logIfTure(2 > 1)
```

1. 在Swift中，有一个非常有用的操作符，可以用来快速对nil进行条件判断，那就是 ？？ 这个操作符可以判断输入内容，并在当左侧的值是非nil的optional值时返回其value，左侧是nil时返回右侧的值
2.比如

```swift
var level : Int?
var startLevel = 1

var currentLevel = level ?? startLevel
```
3. 说明

- 在这个例子中我们没有设置过level，因此最后startLeveal被赋值给currentLevel。我们看看 ？？的定义

```swift
func ??<T>(optional: T?,@autoclosure defaultValue: () -> T?) -> T?

func ??<T>(optional: T?,@autoclosure defaultValue: () -> T) -> T
```
- 在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int，但其实在使用时它被自动封装成一个() -> Intt 有了这个提示，测试一下

```swift
func ??<T>(optional: T?, @autoclosure defauleValue: () -> T) -> T {
    switch optional {
    case .Some(let value):
        return value
    case .None:
        return defauleValue()
    }
}
```

- 1. 为什么这里要使用autoclosure，直接接受T作为参数并返回不行吗？这正是autoclosure的一个最值得称赞的地方。假设使用T，那么意味着？？操作符真正取值之前，我们必须准备好一个默认值，这个默认值的准备和计算会降低性
- 2. 我们可以巧妙绕过条件判断和强制转换，以很优雅的写法处理对optional默认值取值了。

### Optional Chaining


------------

- 使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要谨慎，因为Optional Chaining是随时都可能提前返回nil，所以使用Optional Chaining所得到的东西其实都是optional

```swift
class Toy {
    let name: String
    init(name: String){
        self.name = name
    }
    
}

class Pet {
    var toy: Toy?
}

class child {
    var pet: Pet?
}

```

- 在实际使用中，我们想知道小明的宠物的玩具名字的时候，可以通过以下的**Optional Chaining**得到

```swift
let toyName = xiaoming.pet?.toy?.name
```

1. 注意我们最后访问的是name，并且在Toy的定义中name是被定义一个确定的String而非String？但是我们得到的toyName其实还是一个Strin类型，这是由于在Optional Chaining中，我们任意一个 ？.的时候可能遇到nil提前返回，这个时候只能得到nil
2. 在实际使用中，我们在大多数情况下可能更希望使用Optional Chaining来直接取值的代码

```swift
if let toyName = xiaoming.pet?.toy?.name {
    //太好了，小明有宠物，而且宠物还是正好有个玩具
}
```

3. 可能单独拿出来会很清楚，不过稍微结合一下其他特征就会变得很复杂起来

```swift
extension Toy {
    func play(){
    
    }
}
```

4. 我们为Toy定义一个扩展，以及一个玩玩具的play()方法，还是举例小明有玩具玩

```swift
xiaoming.pet?.toy?.play()
```
- 除了小明，还有有很多人等，这时候我们会想要把这一串抽象出来，做一个闭包以方便使用，传入一个child对象，日过小朋友有宠物并且宠物有玩具的话，就去玩

```swift
//无意义代码
let playClosure = {(child: child) -> () in child.pet?.toy?.play()}
```

- **问题在哪里？**

1. play()调用上，定义的时候没有卸载play()的返回，这表示这个方法返回Void。但是经过Optional Chaining得到的optional的结果，也就是说，我们最后得到应该是这样一个closure

```swift
//
let playClosure = {(child: child) -> ()? in child.pet?.toy?.play()}
```

- 这样调用的返回是一个()?，使用的时候我可以通过Optional Chaining来判定方法是否调用成功

```swift
if let result: () = playClosure(xiaoming) {
    print("好开心")
}else{
    print("没有玩具可玩 :(")
}
```
### 操作符
- 与oc不同swift支持重载操作符，它的最常见的使用方式可能就是定义一些简单的计算，比如我们需要一个表示二位向量的结构数据

```swift
struct Vector2D {
    var x = 0.0
    var y = 0.0
}

```

- 一个很简单的需求是两个Vector2D相加

```swift

let v1 = Vector2D(x:2.0,y: 3.0)
let v2 = Vector2D(x:1.0,y: 4.0)
let v3 = Vector2D(x:v1.x + v2.x,y: v1.y + v2.y)
//v3 为 {x 3.0 , y 7.0}
```

1. 如果只做一次的话还好，一般情况下我们会多次这种操作，这样的话，我们可能更愿意定义一个Vector2D相加的操作，来简化代码使其更清晰

2. 对一个两个向量相加，我们可以重载加号操作符

```swift
func +(left: Vector2D, rigth: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + rigth.y, y: left.y + rigth.y)
}
```

- 这样上面两个向量相加的操作，就全部可以用加号表达了

```swift
let v4 = v1 + v2
// v4 为 {v 3.0, y 7.0}
```

- 上面定义的加号，减号，和负号已经存在swift中的运算符了，我们所做的只是变换它的参数进行重载，如果我们定义一个全新的运算符，要做的事情会更多一件，比如点积运算就，它表示两个向量对应坐标的乘积的和，根据定义，并参考重载运算符的方法，我们选取+*来表示这个运算

```swift
func +* (left: Vector2D, rigth: Vector2D) -> Double {
    return left.x * rigth.x + left.y * rigth.y
}
```

- 这是会报错，因为我们没有对这个操作符进行声明，之前可以直接重载 + - * 这样的操作符，是因为他们在swift中已经有定义了，如果我们要新加操作符的话，需要先对其进行声明，告诉编辑器这个月符号其实是一个操作符

```swift
infix operator +* {
    associativity nonoe
    precedence 160
}
```

##### infix

    表示定义的是一个中位操作符，即前后都是输入；其他的修饰子还包括prefix和postfix，不再赘述
	
	
##### 	associativity

    定义了结合律，即多个同类的操作符顺序出现时的计算顺序，比如常见的加法和减法都是left，就是多个加法同时出现时从左往右计算。点乘结果是Double，不会再和其他乘结合使用，所以这里写成none
	
##### 	precedence

    表示运算的优先级，越高越优先计算运算。swift中乘法和除法的优先级是150，加法和减法是140，这里我们定义点积的优先级为160，就是说它应该优先普通的乘除法进行运算
	
- 有了这些之后，我们就可以很简单地进行向量的点积运算了

```swift
let result = v1 +* v2
//输出为14.0
```

1. 最后需要多提一点的是，swift的操作符号是不能定义在局部域中的，因为一个操作符至少要能在全局范围使用，否则也就失去意义

2.另外来自不同module的操作符是有可能产生冲突的，这对于开发者来说是需要特别注意的地方

3.因此在重载或者定义的操作符时，应当尽量将其作为其他某个方法的“简便写法”，而避免在其中实现大量逻辑或者提供独一无二的功能，这样即使出现冲突，使用者也可是通过方法调用的方式使用你的库

## func的参数修饰

- 在声明一个swift的方法适合，我们一般不去指定参数前面的修饰符，而是直接声明参数

```swift
func incrementore(variable: Int) ->Int {
	return variable + 1
	
}
```

1. 这个方法接受一个Int的输入，然后通过将这个输入加1，返回一个新的比喻输入大1的Int，这其实就是一个简单的+1器

2. 错误代码

```swift
func incrementore(variable: Int) ->Int {
	return ++variable
	
}
```

- 会发现编译错误，为什么swift不行呢？因为swift其实一门讨厌变化的语言，所有可能的地方，都默认不可变得，也就是用let进行声明的，这样不仅可以确保安全，也能编译器的性能更有作为，在方法的参数也是如此

1. 我们不写修饰符的话，默认情况下所有参数都是let

```swift
func incrementore(let variable: Int) ->Int {
	return ++variable
	
}
```

2.let的参数不能重新赋值，这是理所当然，要让这个方法正确编译，我们需要做的改动是let 为 var

```swift
func incrementore(var variable: Int) ->Int {
	return ++variable
	
}
```

3. 现在我们的+1器又可以正确工作了：

```swift
func incrementore(var variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(luckyNumber)

//newNumber = 8

print(luckyNumber)
```

- 上面的例子，我们将参数写作var后，通过调用返回的值是正确的，而luckyNumber还保持了原来的值，这说明var只是在方法内部起作用，而不会直接影响输入的值
- 有些时候我们希望在方法内部直接修改输入的值，这个时候我们可以使用inout来对参数进行修饰

```swift
func incrementore(inout variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(&luckyNumber)

//newNumber = 8

print(luckyNumber)
```
- 注意的是参数修饰是具有传递限制的，我们需要保证统一参数的修饰统一的，举例

```swift
func makeIncrementor(addNumber: Int) -> ((inout Int) -> ()){
    func incrementor(inout variable: Int) -> () {
        variable += addNumber;
    }
    return incrementor;
}
```

## 字面量转换

- 所谓字面量，就是指特定的数字，字符串和不耳值这样，能够直截了指出自己的类型并未变量进行赋值的值

```swift
let aNumber = 3
let aString = "Hello"
let aBool = "ture"
```

1. 上述三个都是字面量
2. 在Swift中，Array，Dictionary在使用简单的描述赋值的时候，使用也是字面

```swift
let anArray = [1,2,3]
let aDictionary = ["key1":"value1","key2":"value2"]
```

- Swift为我们提供了很多接口，用来将字面量转换为特定的类型，对于那些实现了字面量转换接口的类型，在提供字面量赋值的时候，就可以简单德按照接口方法中定义

1. 所有的字面量转换接口都电影以一个typealias 和对应init方法
2. 举例

```swift

protocol BooleanLiteralConvertible {
    typealias BooleanLiteralType
    
    init(booleanLiteral value: BooleanLiteralType)
}
```

- 我们需要自己实现一个字面量转换，可以简单地实现定义的init方法，举一个不太有实际意义的的例子

```swift
enum MyBool : Int {
    case myTure, myFalse
}

extension MyBool: BooleanLiteralConvertible {
    init(booleanLiteral value: Bool) {
        self = value ? myTure : myFalse
    }
}


let myTure: MyBool = true
let myFalse: MyBool = false

myTure.rawValue
myFalse.rawValue
```

- 这样我们很容易直接使用Bool的ture和false来对Mybool类型进行赋值

- 举例二

```swift
class Person {
    let name: String
    init(name value: String){
        self.name = value
    }
}
 
```

- 如果通过String赋值来生产Person对象，可以这样写

```swift
//通过String赋值来生产Person对象，可以这样写

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required init(stringLiteral value: String) {
        self.name = value
    }
    required init(extendedGraphemeClusterLiteral value: String){
        self.name = value
    }
    required init(unicodeScalarLiteral value: String) {
        self.name = value
    }
}
```

```swift
//改善初始化方法中调用原来的init(name value: String)

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required convenience init(stringLiteral value: String) {
        self.init(name: value)
    }
    required convenience init(extendedGraphemeClusterLiteral value: String){
        self.init(name: value)
    }
    required convenience init(unicodeScalarLiteral value: String) {
        self.init(name: value)
    }
}

let p: Person = "xiaoMing"
print(p.name)
```


-  上面Person的例子中，我们没有像MyBool中做的哪像，使用extension的方式扩展类，使其中可以字面量渎职，这是因为而心疼死你哦中，我们是不能定义required的初始话方法的，也就是说，我们无法为现有的费final的class添加字面量转换

### 下标

- 在绝大多数语言中使用下标来读写类似数组和字典数据结构的做法，在swift中，array和dicitionary当然也可以实现下标方法来写

```swift
var arr = [1,2,3]
arr[2]
arr[2] = 4

var dic = ["cat":"meow","goat":"min"]
dic["cat"]
dic["cat"] = "miao"
```

- 我们通过下标访问得到的结果是一个Optional的值，这很容易理解，Swift是允许我们自定义下标，我们不仅能对自己写类型自定义下标，也能对那些已经支持小标访问的类型

```swift
subscript(index.Int) -> T
subscript(subRange:Range<Int>) -> Slice<T>

```

1. 他们共有两种，分别接受单个Int类型的序号和一个表明范围的Range<Int>,作为对应返回值也分别是单个元素和一组对应输入返回的元素
2. 我们很难一次性取出某个特定位置的元素。
3. 实心一个接受数组作为下标输入的读取方法

```swift
extension Array {
    subscript(input: [Int]) -> ArraySlice<Element> {
        get {
            var result = ArraySlice<Element>()
            for i in input {
                assert(i < self.count, "Index out of range")
                result.append(self[i])
            }
            return result
        }
        set {
            for(index,i) in input.enumerate(){
                assert(i < self.count, "Index out of range")
                self[i] = newValue[index]
            }
        }
    }
}

```

- 这样，我们的Array的灵活性大大增强了很多

### 方法嵌套

- 我们可以将方法当然变量或者参数来使用，更进一步，我们甚至可以在一个方法中定义新的方法
- 我们写一个网络请求的Request类，可能面临将请求的编码Ulr里的任务

```swift
func appendQuery(var url: String,
                     key: String,
                     value: AnyObject) -> String {
    
    if let dictionary = value as? [String: AnyObject] {
        
        return appendQueryDictionary(url,key,dictionary)
        
    } else if let array = value as? [AnyObject] {
        return appendQueryArray(url,key,array)
    } else {
        return appendQuerySingle(url,key,value)
    }
}
```

```swift
func appendQueryDictionary(var url: String, key: String, value: [String: AnyObject]) -> String{
    return result
}

func appendQueryArray(var url: String, key: String, value: AnyObject) -> String{
    return result
}

func appendQuerySingle(var url: String, key: String, value: AnyObject) -> String{
    return result
}

if let dictionary = value as? [String: AnyObject]{
    return appendQueryDictionary(url, key, dictionary)
}else if array = value as? [AnyObject]{
    return appendQueryArray(url,key,array)
}esle {
    return appendQuerySingle(url,key,value)
}

```

### 命名空间

1. oc一直以来一个地方没有命名空间，所有代码和引用的静态库最终同一个域和二进制中，这样一旦重复类名的话，就会导致编译冲突，我们看看Swift命名

```swift
public class MyClass {
    public class func hello(){
        print("Hello from framework")
    }
}

//class MyClass {
//    class func hello() {
//        print("hello from app")
//    }
//}
```

- 一种就是就是使用类型嵌套方法来指定访问的范围，常见的做法是将名字重复的类型定义到不同的struct中

```swift
struct MyClassContainer1 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer1")
        }
    }
}



struct MyClassContainer2 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer2")
        }
    }
}
```

### Any和AnyObject

1. Any和 AnyObject是Swift中两个妥协的产物

```swift
AnyObject可以代表任何class类型的实例
Any可以表示任何类型，甚至包括方法func类型
```

##### AnyObject


------------

oc中一个叫id的东西，编译器不会对声明id的变量进行类型的检查，它表示任何任意类的实例，


------------

区别

- 两者其实是有区别的，在Swift中编译器不仅不会对AnyObject实例的方法调用做出检查，甚至对AnyObject调用返回Optional的结果，这虽然是符合oc中的概念的，但是Swift环境使用起来就会很非常麻烦，也很危险


------------

- 举例，某个API返回的是一个id，那么在Swift中将被影射AnyObject是可以指定nil，所以这里我们需要一个optional版本

```swift
func someMethod() -> AnyObject? {
    
    //返回一个AnyObject？等价在oc中返回一个id
    return result
}

let anyObject: AnyObject？ = SomeClass.someMethod()
    if let someInstance = anyObject as? SomeRealClass {
        someInstance.funcOfSomeRealClass()
}

如果我们注意到AnyObject的定义，可以发现其实它是一个接口

protocol AnyObject {
    
}

```

* 特别之处，所有的class都是隐藏地实现了这个接口，这也是AnyObject只适用于class类型的原因，而在swift中所有的基本类型，包括Array 和 Dictionary 这些传统意义上是class的东西，都是struct类型，并不能由AnyObject来表示


```swift

let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [AnyObject] = []
array.append(swiftInt)
array.append(swiftString)

```

1. 这里声明一个**int**和**String**，都应该只能被**Any**代表，而不能被**AnyObject**代表
2. 如果去掉**import UIKit**的话就会发现变化

```swift
let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [Any] = []
array.append(swiftInt)
array.append(swiftString)

```

*     **值得一提的是，只使用Swift类型而不转换为Cocoa类型，对性能所有帮助**

### typealias 和泛型接口

* typealias是用来已经存在的重新定义的名字，可以是代码更加清晰
* 使用的语法也十分的简单
* 例子

```swift


func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -> Double {
    
    let dx  =  Double(toPoint.x - toPoint.y)
    let dy  =  Double(toPoint.x - toPoint.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: CGPoint = CGPoint(x: 0, y: 0)
let point: CGPoint = CGPoint(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, toPoint: point)

```

*使用typealias，就可以直接代码里*

```swift

typealias Loaction = CGPoint
typealias Distance = Double

func distanceBetweenPoint(loaction: Loaction, tolocation: Loaction) -> Distance {
    
    let dx  =  Double(loaction.x - tolocation.y)
    let dy  =  Double(loaction.x - tolocation.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: Loaction = Loaction(x: 0, y: 0)
let point: Loaction = Loaction(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, tolocation: point)

```

1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型确定后我们就可以重新命名，另外swift种没有泛型接口
4. 例子来为接口确定一个使用的类型泛型特征


    
```swift

protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element?
}

protocol SquenceType {
    typealias Generator : GeneratorType
    func generate() -> Self.Generator
}
```


1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型类型的确定性得到保证后，我们可以重名了


```swift
 class Person<T>{}

typealias WordId = String
typealias Worker = Person<WorkId>

```

* Swift中没有泛型接口，但是使用typealias我们可以在接口里定义一个必须实现的别名，swift都用到这个技巧


```swift
protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element
}


protocol SqeuenceType {
    typealias Generator : GeneratorType
    func generator() -> Self.Generator
}
```

### 可变参数函数

1. 可变参数函数指的是可以直接接受任意多个参数的函数，我们最熟悉的就是NSString的 -stringwithFormat方法了
2. 下面例子方法参数可以任意变化的，参数第一项是需要格式化的字符串，后面的参数都是第一个参数填空
3. 但是swift简化了很多，写一个可变参数的函数只需要声明参数时在类型后面加上...就可以了


```object-C
NSString *name = @"Tom";
NSData *date = [NSDate date];
NSString *string = [NSString stringWithForamt: @"Hello %@. Date: %@",name,date];
```

4.可变参数旺旺只能作为方法的最后一个参数来使用，而不能呢先声明一个可变参数，然后再声明其他参数，所以我们可以随意放可变参数的位置

```swift
func sum(input: Int...) -> Int{
    return input.reduce(0, combine: +)
}

print(sum(1,2,3,4,5))

```


```swift

func myFunc(number: Int..., string: String){
    number.forEach{
        for i in 0..<$0{
            print("(i + 1): \(string)")
        }
    }
}

myFunc(1,2,3,string: "hello")
```

* 限制自然有的，比如同一个方法只能有一个参数可变的,可变参数都是必须同一种类型，等等
* 比如swift的NSString格式化的声明就是这样处理


```swift

extension NSString {
    convenience init(format: NSString, _ args: CVarArgType...)
        
    
}
```
* 调用的时候和oc一样了


```swift

let name = "Tom"
let date = NSDate()
let string = NSString(format: "Hello %@. Date: %@",name,date)
```

### 初始化方法顺序

1. swift初始化方法需要保证类型的所有属性都被初始化，所以初始化方法的调用顺序很有讲究，在某个类中，初始化方法顺序并不是随意的


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        super.init()
        name = "tiger"
    }
}
```
2. 一般来说，子类的初始化顺序是

*     设置子类自己需要初始化的参数
*     调父类相应的初始化方法 super.init（）
*     对父类的需要改变程序进行设定，name = "tiger"


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        //如果我们需要改变name的话
        //虽然我们没有显示对super.init()进行调用
        //不过由于这是初始话的最后了，swift替我们自动完成
    }
}

```

































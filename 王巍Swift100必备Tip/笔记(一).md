# 柯里化(Currying)

## 在swift中可以将方法进行柯里化，就是多个参数的方法变换成接受第一个参数的方法，并且返回接受余下的参数并且返回结果的新方法。

### 例子

```swift
func addTwoNumber(a:Int)(num:Int) ->Int {
	return a + num
}
```
- 然后通过只传入第一个括号内的参数进行调用，这样将返回另一个方法

```swift
let addToFour = addTwoNumber(4)     //addTouFour 是一个Int -> Int
ler result = addFour(num:6)   //result = 10

```
### 或者

```swift
func greaterThan(comparror: Int)(input : Int) ->Bool {

    return input > comparror;
}

let greaterThan10 = greaterThan(10);

//结果是true
greaterThan10(input: 13)
//结果是false
greaterThan10(input: 9)
```
- 柯里化是一直种量产相识的好方法，可以通过柯里化一个方法模块避免写出很多重复的代码。

### 例子二

- Swift中Select只能使用字符串生成，难以重构，也无法编译检查，一种解决的方式就是利用方法的柯里化

```swift
protocol TargetAction {
     func performAction()
}

struct TargetActionWrapper<T: AnyObject>: TargetAction {
    
    weak var target: T?
    let action: (T) -> () -> ()
    
    func performAction() -> () {
        if let t = target {
            action(t)()
        }
    }
    
}

enum ControlEvent {
    case TouchUpInside
    case ValueChanged
}

class Control {
    
    var actions = [ControlEvent: TargetAction]()
    
    func setTarget<T: AnyObject>(target: T, action:(T) ->() ->(),controlEvent:ControlEvent){
        actions[controlEvent] = TargetActionWrapper(
            target: target,action:action)
    }
    
    func removeTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent] = nil
    }
    
    func performActionTargetForControlEvent(controlEvent: ControlEvent){
        actions[controlEvent]?.performAction()
    }
    
}
```

- 借助柯里化，安全地改造和利用**target-action**

### 将protocol的方法声明为mutating

- Swift的protocol不仅可以被class类实现，也适用于struct和enum，因为这个原因，我们在写接口给别人的时候需要考虑是否使用mutating来修饰方法
- 比如定义mutating func mymethod(),Swift中mutating关键字修饰方法是为了能在该方法修改struct或者enum的变量，所以如果没有接口方法里mutating，别人如果用struct或者enum来实现这个接口，就不能在方法里改变自己的变量了
- 例子

```swift
protocol Vehicle {
    
    var numberOfWheels: Int {get}
    var color: UIColor {get set}
    
    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()
    
    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```
- 如果把protocol定义中的mutating去掉的话，MyCar就怎么都编译不了：会出现没有实现接口，如果去掉mutating的话，会报错不能改变结构体成员
- 另外，会使用class来实现mutating的方法的接口时，具体实现的面前是不需要加mutating修饰的，因为class可以随意更变自己的成员变量，所以在接口用mutating修饰方法，对于class的实现完全透明，可以当做不存在

### Sequence

- 1. Swift的for...in可以用在所有实现了SequenceType的类型上，而为了实现SequenceType你首页需要实现一个GenertorType
- 2. 比如实现一个反向的generator和sequence可以这么写

```swift
//想定义一个实现GeneratorType protocol 的类型
//GeneratorType 需要指定一个typealias Element
//以及提供一个返回Element?的方法 next()

class ReverseGenerator: GeneratorType {
    typealias Element = Int
    
    var counter: Element
    init<T>(array: [T]) {
        self.counter = array.count - 1
    }
    
    init(statr: Int){
        self.counter = statr
    }
    func next() -> Element? {
        return self.counter < 0 ? nil : counter--
    }
    
}

//然后我们来定义 SequenceType
//和GeneratorType很类似，不过缓存指定一个 typealias Generator
//以及提供一个返回Generator?的方法 genertae()

struct ReverseSequence<T>: SequenceType {
    
    var array: [T]
    
    init (array: [T]){
        self.array = array
    }
    typealias Generator = ReverseGenerator
    
    func generate() -> Generator {
        
        return ReverseGenerator(array:array)
    }
    
}

let arr = [0,1,2,3,4]

for i in ReverseSequence(array: arr){
    print("Index \(i) is (arr[i])")
}
```

- 如果想要研究for...in 这样的方法到底做了什么，就将其展开。

```swift
var g = arrar.generate()

while let obj = g.next(){
    print(obj)
}
```

- 顺便可以得到的收益可以使用map，filter和reduce这些方法，因为SequenceType接口扩展(protocol extension）已经实现他们

```swift
extension SequenceType {
    func map<T>(@noescape transform: (Self.Generator.Element) -> T) ->[T]
    func filter(@noescape includeElement:(Self.Generator.Element) -> Bool) -> [Self.Generator.Element]
    func reduce<T>(inittial: T,@noescape combine: (T, Self.Generator.Element) - >T) -> T
}
```

### 多元组(Tuple)

- 交换输入

```swift

func swapMe<T>(inout a: T, inout b: T){
    let temp = a
    a = b
    b = temp
}

```

- 上述是普通的写法，一下就是使用多元组的话，我们可以不适用额外空间完成交换

```swift
func swapMe<T>(inout a: T, inout b: T){
    (a,b) = (b,a)
}
```

- 说明：
1. 在oc中有不少需要传递指针的地方，以前的错误处理NSError就是个很好的例子，不过在Swift2.0中，传入指针的NSError已经新加入的异常机制取代，所以举例说明

```
//CGRectDivide(CGRect rect, CGRect *slice, CGRect *remainder, CGFloat amount, CGRectEdge edge)

CGRect rect = CGRectMake(0,0,100,100);
CGRect small;
CGRect large;
CGRectDivide(rect, &small, &large, 20, CGRectGetMinXEdge);
```

- 上诉代码不直观又很麻烦，我们用Swift采用多元组方式同时返回被分割的部分和剩余的部分

```swift
extension CGRect {
    func divide(atDistance: CGFloat, formEdge: CGRectEdge) ->(slice: CGRect,remainder: CGRect)
}
```

- 然后使用时，相比之前的做法，现在就非常简单了，而且非常容易理解

```swift
let rect = CGRectMake(0,0,100,100)
let (small,large) = rect.divide(20,fromEdge: .MinXEdge)
```

### @autoclosure和 ？？

- @autoclosure做的事情就是把一句表达式自动分封装成一个闭包(closure)

- 比如我们有一个方法接受一个闭包，当闭包执行的结果true的时候进行打印

```swift
func logIfTrue(predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```
- 在调用的时候，代码可以这样写

```swift
logIfTrue({return 2 > 1})
```
- 当然对闭包的用法可以进行一步简化

```swift
logIfTrue({2 > 1})
```
- 还可以更进一步，因为这个闭包是最后一个参数，所以可以用尾随闭包的方式把大括号拿出来，然后省略
```swift
logIfTrue{2 > 1}
```
-  @autoclosure来实现效果，在参数前面加上 @autoclosure关键字

```swift
func logIfTure(@autoclosure predicate: () -> Bool) {
    if predicate() {
        print("True")
    }
}
```

- 这时候我们可以直接使用下面的代码进行强调用,自动转换为() -> Bool 

```swift
logIfTure(2 > 1)
```

1. 在Swift中，有一个非常有用的操作符，可以用来快速对nil进行条件判断，那就是 ？？ 这个操作符可以判断输入内容，并在当左侧的值是非nil的optional值时返回其value，左侧是nil时返回右侧的值
2.比如

```swift
var level : Int?
var startLevel = 1

var currentLevel = level ?? startLevel
```
3. 说明

- 在这个例子中我们没有设置过level，因此最后startLeveal被赋值给currentLevel。我们看看 ？？的定义

```swift
func ??<T>(optional: T?,@autoclosure defaultValue: () -> T?) -> T?

func ??<T>(optional: T?,@autoclosure defaultValue: () -> T) -> T
```
- 在这里我们的输入满足的是后者，虽然表面上看startLevel只是一个Int，但其实在使用时它被自动封装成一个() -> Intt 有了这个提示，测试一下

```swift
func ??<T>(optional: T?, @autoclosure defauleValue: () -> T) -> T {
    switch optional {
    case .Some(let value):
        return value
    case .None:
        return defauleValue()
    }
}
```

- 1. 为什么这里要使用autoclosure，直接接受T作为参数并返回不行吗？这正是autoclosure的一个最值得称赞的地方。假设使用T，那么意味着？？操作符真正取值之前，我们必须准备好一个默认值，这个默认值的准备和计算会降低性
- 2. 我们可以巧妙绕过条件判断和强制转换，以很优雅的写法处理对optional默认值取值了。

### Optional Chaining


------------

- 使用Optional Chaining可以让我们摆脱很多不必要的判断和取值，但是在使用的时候需要谨慎，因为Optional Chaining是随时都可能提前返回nil，所以使用Optional Chaining所得到的东西其实都是optional

```swift
class Toy {
    let name: String
    init(name: String){
        self.name = name
    }
    
}

class Pet {
    var toy: Toy?
}

class child {
    var pet: Pet?
}

```

- 在实际使用中，我们想知道小明的宠物的玩具名字的时候，可以通过以下的**Optional Chaining**得到

```swift
let toyName = xiaoming.pet?.toy?.name
```

1. 注意我们最后访问的是name，并且在Toy的定义中name是被定义一个确定的String而非String？但是我们得到的toyName其实还是一个Strin类型，这是由于在Optional Chaining中，我们任意一个 ？.的时候可能遇到nil提前返回，这个时候只能得到nil
2. 在实际使用中，我们在大多数情况下可能更希望使用Optional Chaining来直接取值的代码

```swift
if let toyName = xiaoming.pet?.toy?.name {
    //太好了，小明有宠物，而且宠物还是正好有个玩具
}
```

3. 可能单独拿出来会很清楚，不过稍微结合一下其他特征就会变得很复杂起来

```swift
extension Toy {
    func play(){
    
    }
}
```

4. 我们为Toy定义一个扩展，以及一个玩玩具的play()方法，还是举例小明有玩具玩

```swift
xiaoming.pet?.toy?.play()
```
- 除了小明，还有有很多人等，这时候我们会想要把这一串抽象出来，做一个闭包以方便使用，传入一个child对象，日过小朋友有宠物并且宠物有玩具的话，就去玩

```swift
//无意义代码
let playClosure = {(child: child) -> () in child.pet?.toy?.play()}
```

- **问题在哪里？**

1. play()调用上，定义的时候没有卸载play()的返回，这表示这个方法返回Void。但是经过Optional Chaining得到的optional的结果，也就是说，我们最后得到应该是这样一个closure

```swift
//
let playClosure = {(child: child) -> ()? in child.pet?.toy?.play()}
```

- 这样调用的返回是一个()?，使用的时候我可以通过Optional Chaining来判定方法是否调用成功

```swift
if let result: () = playClosure(xiaoming) {
    print("好开心")
}else{
    print("没有玩具可玩 :(")
}
```
### 操作符
- 与oc不同swift支持重载操作符，它的最常见的使用方式可能就是定义一些简单的计算，比如我们需要一个表示二位向量的结构数据

```swift
struct Vector2D {
    var x = 0.0
    var y = 0.0
}

```

- 一个很简单的需求是两个Vector2D相加

```swift

let v1 = Vector2D(x:2.0,y: 3.0)
let v2 = Vector2D(x:1.0,y: 4.0)
let v3 = Vector2D(x:v1.x + v2.x,y: v1.y + v2.y)
//v3 为 {x 3.0 , y 7.0}
```

1. 如果只做一次的话还好，一般情况下我们会多次这种操作，这样的话，我们可能更愿意定义一个Vector2D相加的操作，来简化代码使其更清晰

2. 对一个两个向量相加，我们可以重载加号操作符

```swift
func +(left: Vector2D, rigth: Vector2D) -> Vector2D {
    return Vector2D(x: left.x + rigth.y, y: left.y + rigth.y)
}
```

- 这样上面两个向量相加的操作，就全部可以用加号表达了

```swift
let v4 = v1 + v2
// v4 为 {v 3.0, y 7.0}
```

- 上面定义的加号，减号，和负号已经存在swift中的运算符了，我们所做的只是变换它的参数进行重载，如果我们定义一个全新的运算符，要做的事情会更多一件，比如点积运算就，它表示两个向量对应坐标的乘积的和，根据定义，并参考重载运算符的方法，我们选取+*来表示这个运算

```swift
func +* (left: Vector2D, rigth: Vector2D) -> Double {
    return left.x * rigth.x + left.y * rigth.y
}
```

- 这是会报错，因为我们没有对这个操作符进行声明，之前可以直接重载 + - * 这样的操作符，是因为他们在swift中已经有定义了，如果我们要新加操作符的话，需要先对其进行声明，告诉编辑器这个月符号其实是一个操作符

```swift
infix operator +* {
    associativity nonoe
    precedence 160
}
```

##### infix

    表示定义的是一个中位操作符，即前后都是输入；其他的修饰子还包括prefix和postfix，不再赘述
	
	
##### 	associativity

    定义了结合律，即多个同类的操作符顺序出现时的计算顺序，比如常见的加法和减法都是left，就是多个加法同时出现时从左往右计算。点乘结果是Double，不会再和其他乘结合使用，所以这里写成none
	
##### 	precedence

    表示运算的优先级，越高越优先计算运算。swift中乘法和除法的优先级是150，加法和减法是140，这里我们定义点积的优先级为160，就是说它应该优先普通的乘除法进行运算
	
- 有了这些之后，我们就可以很简单地进行向量的点积运算了

```swift
let result = v1 +* v2
//输出为14.0
```

1. 最后需要多提一点的是，swift的操作符号是不能定义在局部域中的，因为一个操作符至少要能在全局范围使用，否则也就失去意义

2.另外来自不同module的操作符是有可能产生冲突的，这对于开发者来说是需要特别注意的地方

3.因此在重载或者定义的操作符时，应当尽量将其作为其他某个方法的“简便写法”，而避免在其中实现大量逻辑或者提供独一无二的功能，这样即使出现冲突，使用者也可是通过方法调用的方式使用你的库

## func的参数修饰

- 在声明一个swift的方法适合，我们一般不去指定参数前面的修饰符，而是直接声明参数

```swift
func incrementore(variable: Int) ->Int {
	return variable + 1
	
}
```

1. 这个方法接受一个Int的输入，然后通过将这个输入加1，返回一个新的比喻输入大1的Int，这其实就是一个简单的+1器

2. 错误代码

```swift
func incrementore(variable: Int) ->Int {
	return ++variable
	
}
```

- 会发现编译错误，为什么swift不行呢？因为swift其实一门讨厌变化的语言，所有可能的地方，都默认不可变得，也就是用let进行声明的，这样不仅可以确保安全，也能编译器的性能更有作为，在方法的参数也是如此

1. 我们不写修饰符的话，默认情况下所有参数都是let

```swift
func incrementore(let variable: Int) ->Int {
	return ++variable
	
}
```

2.let的参数不能重新赋值，这是理所当然，要让这个方法正确编译，我们需要做的改动是let 为 var

```swift
func incrementore(var variable: Int) ->Int {
	return ++variable
	
}
```

3. 现在我们的+1器又可以正确工作了：

```swift
func incrementore(var variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(luckyNumber)

//newNumber = 8

print(luckyNumber)
```

- 上面的例子，我们将参数写作var后，通过调用返回的值是正确的，而luckyNumber还保持了原来的值，这说明var只是在方法内部起作用，而不会直接影响输入的值
- 有些时候我们希望在方法内部直接修改输入的值，这个时候我们可以使用inout来对参数进行修饰

```swift
func incrementore(inout variable: Int) ->Int {
    return ++variable
    
}

var luckyNumber = 7
let newNumber = incrementore(&luckyNumber)

//newNumber = 8

print(luckyNumber)
```
- 注意的是参数修饰是具有传递限制的，我们需要保证统一参数的修饰统一的，举例

```swift
func makeIncrementor(addNumber: Int) -> ((inout Int) -> ()){
    func incrementor(inout variable: Int) -> () {
        variable += addNumber;
    }
    return incrementor;
}
```

## 字面量转换

- 所谓字面量，就是指特定的数字，字符串和不耳值这样，能够直截了指出自己的类型并未变量进行赋值的值

```swift
let aNumber = 3
let aString = "Hello"
let aBool = "ture"
```

1. 上述三个都是字面量
2. 在Swift中，Array，Dictionary在使用简单的描述赋值的时候，使用也是字面

```swift
let anArray = [1,2,3]
let aDictionary = ["key1":"value1","key2":"value2"]
```

- Swift为我们提供了很多接口，用来将字面量转换为特定的类型，对于那些实现了字面量转换接口的类型，在提供字面量赋值的时候，就可以简单德按照接口方法中定义

1. 所有的字面量转换接口都电影以一个typealias 和对应init方法
2. 举例

```swift

protocol BooleanLiteralConvertible {
    typealias BooleanLiteralType
    
    init(booleanLiteral value: BooleanLiteralType)
}
```

- 我们需要自己实现一个字面量转换，可以简单地实现定义的init方法，举一个不太有实际意义的的例子

```swift
enum MyBool : Int {
    case myTure, myFalse
}

extension MyBool: BooleanLiteralConvertible {
    init(booleanLiteral value: Bool) {
        self = value ? myTure : myFalse
    }
}


let myTure: MyBool = true
let myFalse: MyBool = false

myTure.rawValue
myFalse.rawValue
```

- 这样我们很容易直接使用Bool的ture和false来对Mybool类型进行赋值

- 举例二

```swift
class Person {
    let name: String
    init(name value: String){
        self.name = value
    }
}
 
```

- 如果通过String赋值来生产Person对象，可以这样写

```swift
//通过String赋值来生产Person对象，可以这样写

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required init(stringLiteral value: String) {
        self.name = value
    }
    required init(extendedGraphemeClusterLiteral value: String){
        self.name = value
    }
    required init(unicodeScalarLiteral value: String) {
        self.name = value
    }
}
```

```swift
//改善初始化方法中调用原来的init(name value: String)

class Person: StringLiteralConvertible {
    let name: String
    init(name value: String){
        self.name = value
    }
    
    required convenience init(stringLiteral value: String) {
        self.init(name: value)
    }
    required convenience init(extendedGraphemeClusterLiteral value: String){
        self.init(name: value)
    }
    required convenience init(unicodeScalarLiteral value: String) {
        self.init(name: value)
    }
}

let p: Person = "xiaoMing"
print(p.name)
```


-  上面Person的例子中，我们没有像MyBool中做的哪像，使用extension的方式扩展类，使其中可以字面量渎职，这是因为而心疼死你哦中，我们是不能定义required的初始话方法的，也就是说，我们无法为现有的费final的class添加字面量转换

### 下标

- 在绝大多数语言中使用下标来读写类似数组和字典数据结构的做法，在swift中，array和dicitionary当然也可以实现下标方法来写

```swift
var arr = [1,2,3]
arr[2]
arr[2] = 4

var dic = ["cat":"meow","goat":"min"]
dic["cat"]
dic["cat"] = "miao"
```

- 我们通过下标访问得到的结果是一个Optional的值，这很容易理解，Swift是允许我们自定义下标，我们不仅能对自己写类型自定义下标，也能对那些已经支持小标访问的类型

```swift
subscript(index.Int) -> T
subscript(subRange:Range<Int>) -> Slice<T>

```

1. 他们共有两种，分别接受单个Int类型的序号和一个表明范围的Range<Int>,作为对应返回值也分别是单个元素和一组对应输入返回的元素
2. 我们很难一次性取出某个特定位置的元素。
3. 实心一个接受数组作为下标输入的读取方法

```swift
extension Array {
    subscript(input: [Int]) -> ArraySlice<Element> {
        get {
            var result = ArraySlice<Element>()
            for i in input {
                assert(i < self.count, "Index out of range")
                result.append(self[i])
            }
            return result
        }
        set {
            for(index,i) in input.enumerate(){
                assert(i < self.count, "Index out of range")
                self[i] = newValue[index]
            }
        }
    }
}

```

- 这样，我们的Array的灵活性大大增强了很多

### 方法嵌套

- 我们可以将方法当然变量或者参数来使用，更进一步，我们甚至可以在一个方法中定义新的方法
- 我们写一个网络请求的Request类，可能面临将请求的编码Ulr里的任务

```swift
func appendQuery(var url: String,
                     key: String,
                     value: AnyObject) -> String {
    
    if let dictionary = value as? [String: AnyObject] {
        
        return appendQueryDictionary(url,key,dictionary)
        
    } else if let array = value as? [AnyObject] {
        return appendQueryArray(url,key,array)
    } else {
        return appendQuerySingle(url,key,value)
    }
}
```

```swift
func appendQueryDictionary(var url: String, key: String, value: [String: AnyObject]) -> String{
    return result
}

func appendQueryArray(var url: String, key: String, value: AnyObject) -> String{
    return result
}

func appendQuerySingle(var url: String, key: String, value: AnyObject) -> String{
    return result
}

if let dictionary = value as? [String: AnyObject]{
    return appendQueryDictionary(url, key, dictionary)
}else if array = value as? [AnyObject]{
    return appendQueryArray(url,key,array)
}esle {
    return appendQuerySingle(url,key,value)
}

```

### 命名空间

1. oc一直以来一个地方没有命名空间，所有代码和引用的静态库最终同一个域和二进制中，这样一旦重复类名的话，就会导致编译冲突，我们看看Swift命名

```swift
public class MyClass {
    public class func hello(){
        print("Hello from framework")
    }
}

//class MyClass {
//    class func hello() {
//        print("hello from app")
//    }
//}
```

- 一种就是就是使用类型嵌套方法来指定访问的范围，常见的做法是将名字重复的类型定义到不同的struct中

```swift
struct MyClassContainer1 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer1")
        }
    }
}



struct MyClassContainer2 {
    class MyClass {
        class func hello() {
            print("hello form MyClassContainer2")
        }
    }
}
```

### Any和AnyObject

1. Any和 AnyObject是Swift中两个妥协的产物

```swift
AnyObject可以代表任何class类型的实例
Any可以表示任何类型，甚至包括方法func类型
```

##### AnyObject


------------

oc中一个叫id的东西，编译器不会对声明id的变量进行类型的检查，它表示任何任意类的实例，


------------

区别

- 两者其实是有区别的，在Swift中编译器不仅不会对AnyObject实例的方法调用做出检查，甚至对AnyObject调用返回Optional的结果，这虽然是符合oc中的概念的，但是Swift环境使用起来就会很非常麻烦，也很危险


------------

- 举例，某个API返回的是一个id，那么在Swift中将被影射AnyObject是可以指定nil，所以这里我们需要一个optional版本

```swift
func someMethod() -> AnyObject? {
    
    //返回一个AnyObject？等价在oc中返回一个id
    return result
}

let anyObject: AnyObject？ = SomeClass.someMethod()
    if let someInstance = anyObject as? SomeRealClass {
        someInstance.funcOfSomeRealClass()
}

如果我们注意到AnyObject的定义，可以发现其实它是一个接口

protocol AnyObject {
    
}

```

* 特别之处，所有的class都是隐藏地实现了这个接口，这也是AnyObject只适用于class类型的原因，而在swift中所有的基本类型，包括Array 和 Dictionary 这些传统意义上是class的东西，都是struct类型，并不能由AnyObject来表示


```swift

let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [AnyObject] = []
array.append(swiftInt)
array.append(swiftString)

```

1. 这里声明一个**int**和**String**，都应该只能被**Any**代表，而不能被**AnyObject**代表
2. 如果去掉**import UIKit**的话就会发现变化

```swift
let swiftInt : Int = 1
let swiftString : String = "miao"

var array: [Any] = []
array.append(swiftInt)
array.append(swiftString)

```

*     **值得一提的是，只使用Swift类型而不转换为Cocoa类型，对性能所有帮助**

### typealias 和泛型接口

* typealias是用来已经存在的重新定义的名字，可以是代码更加清晰
* 使用的语法也十分的简单
* 例子

```swift


func distanceBetweenPoint(point: CGPoint, toPoint: CGPoint) -> Double {
    
    let dx  =  Double(toPoint.x - toPoint.y)
    let dy  =  Double(toPoint.x - toPoint.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: CGPoint = CGPoint(x: 0, y: 0)
let point: CGPoint = CGPoint(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, toPoint: point)

```

*使用typealias，就可以直接代码里*

```swift

typealias Loaction = CGPoint
typealias Distance = Double

func distanceBetweenPoint(loaction: Loaction, tolocation: Loaction) -> Distance {
    
    let dx  =  Double(loaction.x - tolocation.y)
    let dy  =  Double(loaction.x - tolocation.y)
    
    return sqrt(dx * dx + dy * dy)
}

let origin: Loaction = Loaction(x: 0, y: 0)
let point: Loaction = Loaction(x: 1, y: 1)

let distance: Double = distanceBetweenPoint(origin, tolocation: point)

```

1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型确定后我们就可以重新命名，另外swift种没有泛型接口
4. 例子来为接口确定一个使用的类型泛型特征


    
```swift

protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element?
}

protocol SquenceType {
    typealias Generator : GeneratorType
    func generate() -> Self.Generator
}
```


1. 同样的代码，在typealias的帮助下，就会轻松很多，可能这么简单的例子不会有特变的体会啊
2. 对于普通类型的没有什么难点
3. 一旦泛型类型的确定性得到保证后，我们可以重名了


```swift
 class Person<T>{}

typealias WordId = String
typealias Worker = Person<WorkId>

```

* Swift中没有泛型接口，但是使用typealias我们可以在接口里定义一个必须实现的别名，swift都用到这个技巧


```swift
protocol GeneratorType {
    typealias Element
    mutating func next() -> Self.Element
}


protocol SqeuenceType {
    typealias Generator : GeneratorType
    func generator() -> Self.Generator
}
```

### 可变参数函数

1. 可变参数函数指的是可以直接接受任意多个参数的函数，我们最熟悉的就是NSString的 -stringwithFormat方法了
2. 下面例子方法参数可以任意变化的，参数第一项是需要格式化的字符串，后面的参数都是第一个参数填空
3. 但是swift简化了很多，写一个可变参数的函数只需要声明参数时在类型后面加上...就可以了


```object-C
NSString *name = @"Tom";
NSData *date = [NSDate date];
NSString *string = [NSString stringWithForamt: @"Hello %@. Date: %@",name,date];
```

4.可变参数旺旺只能作为方法的最后一个参数来使用，而不能呢先声明一个可变参数，然后再声明其他参数，所以我们可以随意放可变参数的位置

```swift
func sum(input: Int...) -> Int{
    return input.reduce(0, combine: +)
}

print(sum(1,2,3,4,5))

```


```swift

func myFunc(number: Int..., string: String){
    number.forEach{
        for i in 0..<$0{
            print("(i + 1): \(string)")
        }
    }
}

myFunc(1,2,3,string: "hello")
```

* 限制自然有的，比如同一个方法只能有一个参数可变的,可变参数都是必须同一种类型，等等
* 比如swift的NSString格式化的声明就是这样处理


```swift

extension NSString {
    convenience init(format: NSString, _ args: CVarArgType...)
        
    
}
```
* 调用的时候和oc一样了


```swift

let name = "Tom"
let date = NSDate()
let string = NSString(format: "Hello %@. Date: %@",name,date)
```

### 初始化方法顺序

1. swift初始化方法需要保证类型的所有属性都被初始化，所以初始化方法的调用顺序很有讲究，在某个类中，初始化方法顺序并不是随意的


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        super.init()
        name = "tiger"
    }
}
```
2. 一般来说，子类的初始化顺序是

*     设置子类自己需要初始化的参数
*     调父类相应的初始化方法 super.init（）
*     对父类的需要改变程序进行设定，name = "tiger"


```swift
class Cat {
    var name = String()
    init(){
        name = "cat"
    }
}

class Tiger: Cat {
    let power: Int
    override init() {
        power = 10
        //如果我们需要改变name的话
        //虽然我们没有显示对super.init()进行调用
        //不过由于这是初始话的最后了，swift替我们自动完成
    }
}

```

### Designated,Convenience和Required
1. oc中，init方法是非常不安全的，没有人保证init只能调用一次，也没有人保证初始化调用以后实例的各个变量都完成初始化，甚至如果在初始化里使用属性进行设置的话，还可能造成各种问题
2. 下面代码，注意init里我们可对let的实例常量赋值，这是初始化方法的重要特点


```swift
class ClassA {
    let numA: Int
    init(num: Int){
        numA = num
    }
}

class ClassB: ClassA {
    let numB: Int
    
    override init(num: Int) {
        numB = num + 1
        
        super.init(num: num)
    }
}
```

3.  Designated初始化方法对应的是init前面加上Convenience关键字的初始方法，这类方法是swift初始化方法的“二等公民”


```swift


class ClassA {
    let numA: Int
    init(num: Int){
        numA = num
    }
    
    convenience init(bigNum: Bool){
        self.init(num:bigNum ? 1000 : 1)
    }
}



class ClassB: ClassA {
    let numB: Int
    
    override init(num: Int) {
        numB = num + 1
        
        super.init(num: num)
    }
}
```
4.   只有在子类实现重写父类convenience方法所需要init方法，我们在子类中就可以使用父类convenience方法

* 初始化路径必须保证对象完全初始化，这可以通过调用类型Designated初始化得到保证
* 子类的Designated初始化方法必须调用父类的designated方法来完成初始化

### 初始化返回nil
1. oc中init方法返回self以外，其实和一个普通的实例方法并没有太大的区别，但是swift中默认情况下初始化方法是不能写成retur语句来返回值的，也就说我们没有机会初始化一个optional的值
2. 一个很经典的例子就是初始化一个url，在oc中，如果我们使用一个错误的字符串来初始化一个NSURL对象，返回时nil，达标初始化失败，只是结果是nil

```oc
    NSURL *url = [NSURL alloc] initWithString:@"http://swifter.tips"];
    NSLog(@"%@"，url);
    
```


```swift
    let url = NSURL(string: "http://swifter.tips")
print(url)
    
```
3.如果是swift 1.0的话

```swift
    class func URLWithString(URLString: String!) -> self!

let url = NSURL(string: "http://swifter.tips")
print(url)
    
```

4.如果是swift 2.2


```swift
extension Int {
    init?(fromString: String){
        self = 0
        var digit = fromString.characters.count - 1
        for c in fromString.characters {
            var number = 0
            if let n = Int(String(c)){
                number = n
            }else {
                switch c {
                    case "一": number = 1
                    case "二": number = 2
                    case "三": number = 3
                    case "四": number = 4
                    case "五": number = 5
                    case "六": number = 6
                    case "七": number = 7
                    case "八": number = 8
                    case "九": number = 9
                default:return nil
                }
            }
            self = self + number * Int(pow(10, Double(digit)))
            digit = digit - 1
        }
    }
}

let number1 = Int(fromString: "12")

let number2 = Int(fromString: "三二五")

let number3 = Int(fromString: "七9八")

let number4 = Int(fromString: "吃了吗")

let number5 = Int(fromString: "1a4n")
```

* 所有结果都是Int?类型，通过Optional Binding，我们就能知道初始化是否成功，并安全的使用它们，在初始化失败的情况下，我们应该使用返回nil的初始化方法，而不是类型工厂方法

### Protocol组合

* 在swift中我们可以使用any来表示任意类型，这个类型的定义十分奇怪，它是一个Protocol<>的同名类型
* 像Protocol<>这种形式的写法在swift的日常使用并不多见，这其实是swift的接口组合的用法，标准的形式是
* protocol < ProtocolA,ProtocolB,ProtocolC >
* 例子，有三个接口，分别代表三种动物，而有一种“谜之动物”，同时实现了这三个接口


```swift
protocol KittenLike {
    func meow() -> String
}

protocol DogLike {
    func brak() -> String
}

protocol TigerLike {
    func aou() -> String
}

class MyterAnimal: KittenLike,DogLike,TigerLike {
    func meow() -> String {
        return "meow"
    }
    
    func brak() -> String {
        return "bark"
    }
    
    func aou() -> String {
        return "aou"
    }
}

```
* 现在我们想要检验某种动物作为宠物的时候的叫声的话，可能重新定义一个叫做PetLike的接口，表示实现了PetLike和DogLike


```swif
protocol PetLike: KittenLike,DogLike {
    
}

protocol CatLike: KittenLike,DogLike {
    
}

struct SoundChecker {
    static func checkPetTalking(pet: PetLike){
    
    }
    static func checkCatTalking(cat: PetLike){
        
    }
}

```
1. 虽然没有引入定义任何新的内容，但是为了实现这个需求，我们还是添加了两个空 protocol，这可能会让人困惑，代码的使用者 (也包括一段时间后的你自己) 可能会去猜测 PetLike 和 CatLike 的作用 --
2.  其实它们除了标注以外并没有其他作用。借助 protocol 组合的特性，我们可以很好的解决这个问题。protocol 组合是可以使用 typealias 来命名的，于是可以将上面的新定义 protocol 的部分换为：


```swift
typealias PetLike = protocol<KittenLike, DogLike>
typealias CatLike = protocol<KittenLike, TigerLike>
```

* 这样既保持了可读性，也没有多定义不必要的新类型。
* 另外，其实如果这两个临时接口我们就只用一次的话，如果上下文里理解起来不会有困难，我们完全可以直接将它们匿名化，变成下面这样：


```swift
struct SoundChecker {
    static func checkPetTalking(pet: protocol<KittenLike, DogLike>) {
        //...
    }

    static func checkCatTalking(cat: protocol<KittenLike, TigerLike>) {
        //...
    }
}
```
* 两个接口中 bar() 只有返回值的类型不同。
* 我们如果有一个类型 Class 同时实现了 A 和 B，我们要怎么才能避免和解决调用冲突呢？


```swift
class Class: A, B {
    func bar() -> Int {
        return 1
    }

    func bar() -> String {
        return "Hi"
    }
}
```

这样一来，对于 bar()，只要在调用前进行类型转换就可以了：


```swift
let instance = Class()
let num = (instance as A).bar()  // 1
let str = (instance as B).bar()  // "Hi"
```

### static和class

1. Swift 中表示 “类型范围作用域” 这一概念有两个不同的关键字，它们分别是 static 和 class。
2. 这两个关键字确实都表达了这个意思，但是在其他一些语言，包括 Objective-C 中，我们并不会特别地区分类变量/类方法和静态变量/静态函数。但是在 Swift 的早期版本中中，这两个关键字却是不能用混的。
3. 在非 class 的类型上下文中，我们统一使用 static 来描述类型作用域。
4. 这包括在 enum 和 struct 中表述类型方法和类型属性时。在这两个值类型中，
5. 我们可以在类型范围内声明并使用存储属性，计算属性和方法。static 适用的场景有这些：


```swift
struct Point {
    let x: Double
    let y: Double

    // 存储属性
    static let zero = Point(x: 0, y: 0)

    // 计算属性
    static var ones: [Point] {
        return [Point(x: 1, y: 1),
                Point(x: -1, y: 1),
                Point(x: 1, y: -1),
                Point(x: -1, y: -1)]
    }

    // 类型方法
    static func add(p1: Point, p2: Point) -> Point {
        return Point(x: p1.x + p2.x, y: p1.y + p2.y)
    }
}
```

* enum 的情况与这个十分类似，就不再列举了。
* class 关键字相比起来就明白许多，是专门用在 class 类型的上下文中的，可以用来修饰类方法以及类的计算属性。
* 但是有一个例外，class 中现在是不能出现 class 的存储属性的，我们如果写类似这样的代码的话：


```swift
class MyClass {
    class var bar: Bar?
}
```

*编译时会得到一个错误*
*在 Swift 1.2 及之后，我们可以在 class 中使用 static 来声明一个类作用域的变量。也即：*

```swift
class MyClass {
    static var bar: Bar?
}
```

* 有一个比较特殊的是 protocol。在 Swift 中 class，struct 和 enum 都是可以实现某个 protocol 的。
* 那么如果我们想在 protocol 里定义一个类型域上的方法或者计算属性的话，应该用哪个关键字呢？
* 答案是使用 static 进行定义。在使用的时候，struct 或 enum 中仍然使用 static，而在 class 里我们既可以使用 class 关键字，也可以用 static，它们的结果是相同的：


```swift
protocol MyProtocol {
    static func foo() -> String
}

struct MyStruct: MyProtocol {
    static func foo() -> String {
        return "MyStruct"
    }
}

enum MyEnum: MyProtocol {
    static func foo() -> String {
        return "MyEnum"
    }
}

class MyClass: MyProtocol {
    // 在 class 中可以使用 class
    class func foo() -> String {
        return "MyClass.foo()"
    }

    // 也可以使用 static
    static func bar() -> String {
        return "MyClass.bar()"
    }
}
```

**在 Swift 1.2 之前 protocol 中使用的是 class 作为关键字，但这确实是不合逻辑的。Swift 1.2 和 2.0 分两次对此进行了改进。现在只需要记住结论，在任何时候使用 static 应该都是没有问题的。**

### 多类型和容器

##### Swift 中常用的原生容器类型有三种，它们分别是 Array、Dictionay 和 Set


```swift
struct Array<Element> :
    CollectionType, Indexable, SequenceType,
    MutableCollectionType, _DestructorSafeContainer {

    //...

}

struct Dictionary<Key : Hashable, Value> :
    CollectionType, Indexable, SequenceType,
    DictionaryLiteralConvertible {

    //...

}

public struct Set<Element : Hashable> : 
    Hashable, Equatable, CollectionType, Indexable, 
    SequenceType, ArrayLiteralConvertible {

    //...

}
```

*它们都是泛型的，也就是说我们在一个集合中只能放同一个类型的元素。比如*


```swift
let numbers = [1,2,3,4,5]
// numbers 的类型是 [Int]

let strings = ["hello", "world"]
// strings 的类型是 [String]
```
*如果我们要把不相关的类型放到同一个容器类型中的话，一个比较容易想到的是使用 Any 或者 AnyObject，或者是使用 NSArray：*


```swift
import UIKit

let mixed: [Any] = [1, "two", 3]

// 如果不指明类型，由于 UIKit 的存在
// 将被推断为 [NSObject]
let objectArray = [1, "two", 3]
```
*这样的转换会造成部分信息的损失，我们从容器中取值时只能得到信息完全丢失后的结果，在使用时还需要进行一次类型转换。这其实是在无其他可选方案后的最差选择：因为使用这样的转换的话，编译器就不能再给我们提供警告信息了。我们可以随意地将任意对象添加进容器，也可以将容器中取出的值转换为任意类型，这是一件十分危险的事情：*

```swift
let any = mixed[0]  // Any 类型
let nsObject = objectArray[0] // NSObject 类型
```

**其实我们注意到，Any 其实是 protocol，而不是具体的某个类型。因此就是说其实在容器类型泛型的帮助下，我们不仅可以在容器中添加同一具体类型的对象，也可以添加实现了同一接口的类型的对象。绝大多数情况下，我们想要放入一个容器中的元素或多或少会有某些共同点，这就使得用接口来规定容器类型会很有用。比如上面的例子如果我们希望的是打印出容器内的元素的 description，可能我们更倾向于将数组声明为 [CustomStringConvertible] 的：**


```swift
import Foundation
let mixed: [CustomStringConvertible] = [1, "two", 3]

for obj in mixed {
    print(obj.description)
}
```

**这种方法虽然也损失了一部分类型信息，但是相对于 Any 或者 AnyObject 还是改善很多，在对于对象中存在某种共同特性的情况下无疑是最方便的。另一种做法是使用 enum 可以带有值的特点，将类型信息封装到特定的 enum 中。下面的代码封装了 Int 或者 String 类型：**

```swift
import Foundation
enum IntOrString {
    case IntValue(Int)
    case StringValue(String)
}

let mixed = [IntOrString.IntValue(1),
             IntOrString.StringValue("two"),
             IntOrString.IntValue(3)]

for value in mixed {
    switch value {
    case let .IntValue(i):
        print(i * 2)
    case let .StringValue(s):
        print(s.capitalizedString)
    }
}

// 输出：
// 2
// Two
// 6
```

* 通过这种方法，我们完整地在编译时保留了不同类型的信息。为了方便，我们甚至可以进一步为 IntOrString 使用字面量转换的方法编写简单的获取方式，但那是另外一个故事了

### default参数

1. Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。
2. 在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。
3. 可以说这是 Objective-C 社区盼了好多年的一个特性了，Objective-C 由于语法的特点几乎无法在不大幅改动的情况下很好地实现默认参数。
4. 和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 "默认参数之后不能再出现无默认值的参数"这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：


```swift
func sayHello1(str1: String = "Hello", str2: String, str3: String) {
    print(str1 + str2 + str3)
}

func sayHello2(str1: String, str2: String, str3: String = "World") {
    print(str1 + str2 + str3)
}
```

**其他不少语言只能使用后面一种写法，将默认参数作为方法的最后一个参数。
在调用的时候，我们如果想要使用默认值的话，只要不传入相应的值就可以了。下面这样的调用将得到同样的结果：**


```swift
sayHello1(str2: " ", str3: "World")
sayHello2("Hello", str2: " ")

//输出都是 Hello World
```

**这两个调用都省略了带有默认值的参数，sayHello1 中 str1 是默认的 "Hello"，而 sayHello2 中的 str3 是默认的 "World"。
另外如果喜欢 Cmd + 单击点来点去到处看的朋友可能会注意到 NSLocalizedString 这个常用方法的签名现在是：**


```swift
func NSLocalizedString(key: String,
                 tableName: String? = default,
                    bundle: NSBundle = default,
                     value: String = default,
                   comment: String) -> String
```

* 默认参数写的是 default，这是含有默认参数的方法所生成的 Swift 的调用接口。
* 当我们指定一个编译时就能确定的常量来作为默认参数的取值时，这个取值是隐藏在方法实现内部，而不应该暴露给其他部分。与 NSLocalizedString 很相似的还有 Swift 中的各类断言：


```swift
func assert(@autoclosure condition: () -> Bool,
            @autoclosure _ message: () -> String = default,
                              file: StaticString = default,
                              line: UWord = default)
```

### 正则表达式

1. 作为一门先进的编程语言，Swift 可以说吸收了众多其他先进语言的优点，但是有一点却是让人略微失望的，就是 Swift 至今为止并没有在语言层面上支持正则表达式。
2. 大概是因为其实 app 开发并不像 Perl 或者 Ruby 那样的语言需要处理很多文字匹配的问题，Cocoa 开发者确实不是特别依赖正则表达式。但是并不排除有希望使用正则表达式的场景，我们是否能像其他语言一样，使用比如 =~ 这样的符号来进行正则匹配呢？
3. 最容易想到也是最容易实现的当然是自定义 =~ 这个运算符。在 Cocoa 中我们可以使用 NSRegularExpression 来做正则匹配，那么其实我们为它写一个包装也并不是什么太困难的事情。因为做的是字符串正则匹配，所以 =~ 左右两边都是字符串。
4. 我们可以先写一个接受正则表达式的字符串，以此生成 NSRegularExpression 对象。然后使用该对象来匹配输入字符串，并返回结果告诉调用者匹配是否成功。一个最简单的实现可能是下面这样的


```swift
struct RegexHelper {
    let regex: NSRegularExpression

    init(_ pattern: String) throws {
        try regex = NSRegularExpression(pattern: pattern,
            options: .CaseInsensitive)
    }

    func match(input: String) -> Bool {
        let matches = regex.matchesInString(input,
                    options: [],
                    range: NSMakeRange(0, input.utf16.count))
        return matches.count > 0
    }
}
```

**在使用的时候，比如我们想要匹配一个邮箱地址，我们可以这样来使用：**


```swift
let mailPattern =
"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$"

let matcher: RegexHelper
do {
    matcher = try RegexHelper(mailPattern)
}

let maybeMailAddress = "onev@onevcat.com"

if matcher.match(maybeMailAddress) {
    print("有效的邮箱地址")
}
// 输出:
// 有效的邮箱地址
```

**现在我们有了方便的封装，接下来就让我们实现 =~ 吧。这里只给出结果了，关于如何实现操作符和重载操作符的内容，可以参考操作符一节的内容。**


```swift
infix operator =~ {
    associativity none
    precedence 130
}

func =~(lhs: String, rhs: String) -> Bool {
    do {
        return try RegexHelper(rhs).match(lhs)
    } catch _ {
        return false
    }
}
```

* 这下我们就可以使用类似于其他语言的正则匹配的方法了：


```swift
if "onev@onevcat.com" =~
    "^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$" {
        print("有效的邮箱地址")
}
// 输出:
// 有效的邮箱地址
```

### 模式匹配

1. 在之前的正则表达式中，我们实现了 =~ 操作符来完成简单的正则匹配。虽然在 Swift 中没有内置的正则表达式支持，但是一个和正则匹配有些相似的特性其实是内置于 Swift 中的，那就是模式匹配。
2. 当然，从概念上来说正则匹配只是模式匹配的一个子集，但是在 Swift 里现在的模式匹配还很初级，也很简单，只能支持最简单的相等匹配和范围匹配。在 Swift 中，使用 ~= 来表示模式匹配的操作符。如果我们看看 API 的话，可以看到这个操作符有下面几种版本：


```swift
func ~=<T : Equatable>(a: T, b: T) -> Bool

func ~=<T>(lhs: _OptionalNilComparisonType, rhs: T?) -> Bool

func ~=<I : IntervalType>(pattern: I, value: I.Bound) -> Bool
```

* 从上至下在操作符左右两边分别接收可以判等的类型，可以与 nil 比较的类型，以及一个范围输入和某个特定值，返回值很明了，都是是否匹配成功的 Bool 值。你是否有想起些什么呢..没错，就是 Swift 中非常强大的 switch，我们来看看 switch 的几种常见用法吧：

###### 可以判等的类型的判断


```swift
let password = "akfuv(3"
switch password {
    case "akfuv(3": print("密码通过")
    default:        print("验证失败")
}
```
##### 对 Optional 的判断

```swift
let num: Int? = nil
switch num {
    case nil: print("没值")
    default:  print("\(num!)")
}
```
##### 对范围的判断

```swift

let x = 0.5
switch x {
    case -1.0...1.0: print("区间内")
    default: print("区间外")
}
```

**这并不是巧合。没错，Swift 的 switch 就是使用了 ~= 操作符进行模式匹配，case 指定的模式作为左参数输入，而等待匹配的被 switch 的元素作为操作符的右侧参数。只不过这个调用是由 Swift 隐式地完成的。于是我们可以发挥想象的地方就很多了，比如在 switch 中做 case 判断的时候，我们完全可以使用我们自定义的模式匹配方法来进行判断，有时候这会让代码变得非常简洁，具有条理。我们只需要按照需求重载 ~= 操作符就行了，接下来我们通过一个使用正则表达式做匹配的例子加以说明。
首先我们要做的是重载 ~= 操作符，让它接受一个 NSRegularExpression 作为模式，去匹配输入的 String：**


```swift
func ~=(pattern: NSRegularExpression, input: String) -> Bool {
    return pattern.numberOfMatchesInString(input,
        options: [],
        range: NSRange(location: 0, length: input.characters.count)) > 0
}
```

1. 然后为了简便起见，我们再添加一个将字符串转换为 NSRegularExpression 的操作符 (当然也可以使用 StringLiteralConvertible，但是它不是这个 tip 的主题，在此就先不使用它了)：

```swift
prefix operator ~/ {}

prefix func ~/(pattern: String) -> NSRegularExpression {
    return NSRegularExpression(pattern: pattern, options: nil, error: nil)
}
```

* 现在，我们在 case 语句里使用正则表达式的话，就可以去匹配被 switch 的字符串了：

```swift

let contact = ("http://onevcat.com", "onev@onevcat.com")

let mailRegex: NSRegularExpression
let siteRegex: NSRegularExpression

mailRegex = 
    try ~/"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$"
siteRegex = 
    try ~/"^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$"

switch contact {
    case (siteRegex, mailRegex): print("同时拥有有效的网站和邮箱")
    case (_, mailRegex): print("只拥有有效的邮箱")
    case (siteRegex, _): print("只拥有有效的网站")
    default: print("嘛都没有")
}

// 输出
// 同时拥有网站和邮箱

```

### ...和..<

1. 在很多脚本语言中 (比如 Perl 和 Ruby)，都有类似 0..3 或者 0...3 这样的 Range 操作符，用来简单地指定一个从 X 开始连续计数到 Y 的范围。
2. 这个特性不论在哪个社区，都是令人爱不释手的写法，Swift 中将其光明正大地 "借用" 过来，也就不足为奇了。
3. 最基础的用法当然还是在两边指定数字，0...3 就表示从 0 开始到 3 为止并包含 3 这个数字的范围，我们将其称为全闭合的范围操作；而在某些时候 (比如操作数组的 index 时)，我们更常用的是不包括最后一个数字的范围。这在 Swift 中被用一个看起来有些奇怪，但是表达的意义很清晰的操作符来定义，写作 0..<3 -- 都写了小于号了，自然是不包含最后的 3 的意思咯。
4. 对于这样得到的数字的范围，我们可以对它进行 for...in 的访问：


```swift
for i in 0...3 {
    print(i, terminator: "")
}

//输出 0123
```

**如果你认为 ... 和 ..< 只有这点内容的话，就大错特错了。我们可以仔细看看 Swift 中对着两个操作符的定义 (为了清晰，我稍微更改了一下它们的次序)：**


```swift
/// Forms a closed range that contains both `minimum` and `maximum`.
func ...<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos)
        -> Range<Pos>

/// Forms a closed range that contains both `start` and `end`.
/// Requres: `start <= end`
func ...<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos)
        -> Range<Pos>


/// Forms a half-open range that contains `minimum`, but not
/// `maximum`.
func ..<<Pos : ForwardIndexType>(minimum: Pos, maximum: Pos)
        -> Range<Pos>

/// Forms a half-open range that contains `start`, but not
/// `end`.  Requires: `start <= end`
func ..<<Pos : ForwardIndexType where Pos : Comparable>(start: Pos, end: Pos)
        -> Range<Pos>


/// Returns a closed interval from `start` through `end`
func ...<T : Comparable>(start: T, end: T) -> ClosedInterval<T>

/// Returns a half-open interval from `start` to `end`
func ..<<T : Comparable>(start: T, end: T) -> HalfOpenInterval<T>
```

1. 不难发现，其实这几个方法都是支持泛型的。除了我们常用的输入 Int 或者 Double，返回一个 Range 以外，这个操作符还有一个接受 Comparable 的输入，并返回 ClosedInterval 或 HalfOpenInterval 的重载。
2. 在 Swift 中，除了数字以外另一个实现了 Comparable 的基本类型就是 String。也就是说，我们可以通过 ... 或者 ..< 来连接两个字符串。一个常见的使用场景就是检查某个字符是否是合法的字符。比如想确认一个单词里的全部字符都是小写英文字母的话，可以这么做：


```swift
let test = "helLo"
let interval = "a"..."z"
for c in test.characters {
    if !interval.contains(String(c)) {
        print("\(c) 不是小写字母")
    }
}

// 输出
// L 不是小写字母
```

* 在日常开发中，我们可能会需要确定某个字符是不是有效的 ASCII 字符，和上面的例子很相似，我们可以使用 \0...~ 这样的 ClosedInterval 来进行 (\0 和 ~ 分别是 ASCII 的第一个和最后一个字符)。

### ANYCLASS，元类型和 .SELF

* 在 Swift 中能够表示 “任意” 这个概念的除了 Any 和 AnyObject 以外，还有一个 AnyClass。AnyClass 在 Swift 中被一个 typealias 所定义：


```swift
typealias AnyClass = AnyObject.Type
```

1. 通过 AnyObject.Type 这种方式所得到是一个元类型 (Meta)。在声明时我们总是在类型的名称后面加上 .Type，比如 A.Type 代表的是 A 这个类型的类型。也就是说，我们可以声明一个元类型来存储 A 这个类型本身，而在从 A 中取出其类型时，我们需要使用到 .self：


```swift
class A {

}

let typeA: A.Type = A.self
```

**了解了这个基础之后，我们就明白 AnyObject.Type，或者说 AnyClass 所表达的东西其实并没有什么奇怪，就是任意类型本身。所以，上面对于 A 的类型的取值，我们也可以强制让它是一个 AnyClass：**


```swift
class A {

}

let typeA: AnyClass = A.self
```

**这样，要是 A 中有一个类方法时，我们就可以通过 typeA 来对其进行调用了：**


```swift
class A {
    class func method() {
        print("Hello")
    }
}

let typeA: A.Type = A.self
typeA.method()

// 或者
let anyClass: AnyClass = A.self
(anyClass as! A.Type).method()
```

* 也许你会问，这样做有什么意义呢，我们难道不是可以直接使用 A.method() 来调用么？没错，对于单个独立的类型来说我们完全没有必要关心它的元类型，但是元类型或者元编程的概念可以变得非常灵活和强大，这在我们编写某些框架性的代码时会非常方便。
* 比如我们想要传递一些类型的时候，就不需要不断地去改动代码了。在下面的这个例子中虽然我们是用代码声明的方式获取了 MusicViewController 和 AlbumViewController 的元类型，但是其实这一步骤完全可以通过读入配置文件之类的方式来完成的。而在将这些元类型存入数组并且传递给别的方法来进行配置这一点上，元类型编程就很难被替代了：


```swift
class MusicViewController: UIViewController {

}

class AlbumViewController: UIViewController {

}

let usingVCTypes: [AnyClass] = [MusicViewController.self,
    AlbumViewController.self]

func setupViewControllers(vcTypes: [AnyClass]) {
    for vcType in vcTypes {
        if vcType is UIViewController.Type {
            let vc = (vcType as! UIViewController.Type).init()
            print(vc)
        }

    }
}

setupViewControllers(usingVCTypes)
```

1. 这么一来，我们完全可以搭好框架，然后用 DSL 的方式进行配置，就可以在不触及 Swift 编码的情况下，很简单地完成一系列复杂操作了。
2. 另外，在 Cocoa API 中我们也常遇到需要一个 AnyClass 的输入，这时候我们也应该使用 .self 的方式来获取所需要的元类型，例如在注册 tableView 的 cell 的类型的时候：


```swift
self.tableView.registerClass(
    UITableViewCell.self, forCellReuseIdentifier: "myCell")
```

### 接口和类方法中的 SELF

**我们在看一些接口的定义时，可能会注意到出现了首字母大写的 Self 出现在类型的位置上：**


```swfit
protocol IntervalType {
    //...

    /// Return `rhs` clamped to `self`.  The bounds of the result, even
    /// if it is empty, are always within the bounds of `self`
    func clamp(intervalToClamp: Self) -> Self

    //...
}
```

1. 比如上面这个 IntervalType 的接口定义了一个方法，接受实现该接口的自身的类型，并返回一个同样的类型。
2. 这么定义是因为接口其实本身是没有自己的上下文类型信息的，在声明接口的时候，我们并不知道最后究竟会是什么样的类型来实现这个接口，Swift 中也不能在接口中定义泛型进行限制。而在声明接口时，我们希望在接口中使用的类型就是实现这个接口本身的类型的话，就需要使用 Self 进行指代。
3. 但是在这种情况下，Self 不仅指代的是实现该接口的类型本身，也包括了这个类型的子类。从概念上来说，Self 十分简单，但是实际实现一个这样的方法却稍微要转个弯。为了说明这个问题，我们假设要实现一个 Copyable 的接口，满足这个接口的类型需要返回一个和接受方法调用的实例相同的拷贝。一开始我们可能考虑的接口是这样的


```swift
protocol Copyable {
    func copy() -> Self
}
```

* 这是很直接明了的，它应该做的是创建一个和接受这个方法的对象同样的东西，然后将其返回，返回的类型不应该发生改变，所以写为 Self。然后开始尝试实现一个 MyClass 来满足这个接口：


```swift
class MyClass: Copyable {

    var num = 1

    func copy() -> Self {
        // TODO: 返回什么？
        // return
    }
}
```

**我们一开始的时候可能会写类似这样的代码：**


```swift
这是错误代码
func copy() -> Self {
    let result = MyClass()
    result.num = num
    return result
}
```

1. 但是显然类型是有问题的，因为该方法要求返回一个抽象的、表示当前类型的 Self，但是我们却返回了它的真实类型 MyClass，这导致了无法编译。也许你会尝试把方法声明中的 Self 改为 MyClass，这样声明就和实际返回一致了，但是很快你会发现这样的话，实现的方法又和接口中的定义不一样了，依然不能编译。
2. 为了解决这个问题，我们在这里需要的是通过一个和当前上下文 (也就是和 MyClass) 无关的，又能够指代当前类型的方式进行初始化。希望你还能记得我们在对象类型中所提到的 dynamicType，这里我们就可以使用它来做初始化，以保证方法与当前类型上下文无关，这样不论是 MyClass 还是它的子类，都可以正确地返回合适的类型满足 Self 的要求




```swift
func copy() -> Self {
    let result = self.dynamicType.init()
    result.num = num
    return result
}
```

1. 但是很不幸，单单是这样还是无法通过编译，编译器提示我们如果想要构建一个 Self 类型的对象的话，需要有 required 关键字修饰的初始化方法，
2. 这是因为 Swift 必须保证当前类和其子类都能响应这个 init 方法。另一个解决的方案是在当前类类的声明前添加 final 关键字，告诉编译器我们不再会有子类来继承这个类型。在这个例子中，我们选择添加上 required 的 init 方法。最后，MyClass 类型是这样的：


```swift

class MyClass: Copyable {

    var num = 1

    func copy() -> Self {
        let result = self.dynamicType.init()
        result.num = num
        return result
    }

    required init() {

    }
}
```

**我们可以通过测试来验证一下行为的正确性：**


```swift
let object = MyClass()
object.num = 100

let newObject = object.copy()
object.num = 1

print(object.num)     // 1
print(newObject.num)  // 100
```
**而对于 MyClass 的子类，copy() 方法也能正确地返回子类的经过拷贝的对象了。

另一个可以使用 Self 的地方是在类方法中，使用起来也十分相似，核心就在于保证子类也能返回恰当的类型。**

### 动态类型和多方法

1. Swift 中我们虽然可以通过 dynamicType 来获取一个对象的动态类型 (也就是运行时的实际类型，而非代码指定或编译器看到的类型)。但是在使用中，Swift 现在却是不支持多方法的，也就是说，不能根据对象在动态时的类型进行合适的重载方法调用。
2. 举个例子来说，在 Swift 里我们可以重载同样名字的方法，而只需要保证参数类型不同：


```swift
class Pet {}
class Cat: Pet {}
class Dog: Pet {}

func printPet(pet: Pet) {
    print("Pet")
}

func printPet(cat: Cat) {
    print("Meow")
}

func printPet(dog: Dog) {
    print("Bark")
}
```








    

 































